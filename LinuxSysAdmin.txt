
Linux系统管理
	磁盘管理, 文件系统管理
	RAID基础原理, LVM2
	网络管理: TCP/IP协议, Linux网络属性配置
	程序包管理: rpm, yum
	进程管理: htop, glance, tsar
	sed和awk
	Linux系统开机流程
	内核管理基础知识: 编译内核, 模块
	Linux系统裁剪
		Kernel+busybox
	课外作业: LFS

回顾: find, 特殊权限, if语句

Linux磁盘管理
	
	I/O Ports: I/O设备地址

	一切皆文件: 
		open(), read(), write(), close()

		块设备: block, 存取单位就是"块", 磁盘
		字符设备: char, 存取单位是"字符", 键盘

		设备文件: 关联至一个设备驱动程序, 进而能够与之对应的硬件设备进行通信. 

			设备号码:
				主设备号: major number, 标识设备类型
				次设备号: minor number, 标识同一类型下的不同设备

				[root@localhost ~]# ls -l /dev
				total 0
				crw-rw----. 1 root video    10, 175 Jan 20 03:16 agpgart
				crw-rw----. 1 root root     10,  57 Jan 20 03:17 autofs
				drwxr-xr-x. 2 root root         660 Jan 20 03:17 block
				brw-rw----. 1 root disk      8,   0 Jan 20 03:16 sda
				brw-rw----. 1 root disk      8,   1 Jan 20 03:17 sda1
				brw-rw----. 1 root disk      8,   2 Jan 20 03:16 sda2


				对于设备文件的ls -l结果中的第5列值就不是显示这个文件的大小了,这个数字是用,分割开的
				即: 主设备号,次设备号
				上面命令的结果中, /dev/sda1和/dev/sda2这两个设备文件的主设备号都是8(因为它们是同一类设备),
				而次设备号不同(因为它们是同一类设备下的不同设备).

			硬盘接口类型:
				并行:
					IDE: 133MB/s
					SCSI: 640MB/s (工业级的接口,使用时长,年限大概能达到IDE的4-8倍)
				串口:
					SATA: 6Gbps 约等于 768MB/s
					SAS: 6Gbps
					USB: 480MB/s


					rpm: rotations per minute
				

			/dev/DEV_FILE
				磁盘设备的设备文件命名(早期不太一样,现在全都统一了):
					
					IDE: /dev/hd
					SCSI, SATA, SAS, USB: /dev/sd
						不同设备: a-z
							/dev/sda, /dev/sdb, /dev/sdc, ...
						同一设备上的不同分区: 1,2,3, ...
							/dev/sda1, /dev/sda5 ...

			机械式硬盘的基本工作机制:
				track: 磁道, 真正存储数据的位置
				cylinder: 柱面
				sector: 扇区
					512 bytes, 现在的扇区可能有更大的容量比如4k byte

				如何分区:
					按柱面

				0磁道0扇区: 512 bytes
					MBR: Master Boot Record 
						446 byte: boot loader
						64 byte: 分区表
							16 byte: 标识一个分区, 所以一块磁盘最多只能有4个分区,这4个分区中有一个分区可以是
							扩展分区(逻辑分区),这个扩展分区指向一个更大的存储空间
						2 byte: 55AA
							当前MBR的有效性标识, 一般为4个16进制数字55AA,标识前面510个字节是有效的

						4个主分区:
							3个主分区+1扩展(N个逻辑分区),这个扩展分区不是存储数据的分区,它有n个逻辑分区组成 
							sda1,sda2 ...
							任何一个逻辑分区的编号最小也得是从5开始

						早期的时候,任何一个硬盘最多只能有4个主分区. 现在的硬盘如果是使用UEFI格式引导的话,可以
						支持更多的分区,且它的MBR空间也更大. 但是这种UEFI格式不兼容以前的分区方式,只能二选一

					MBR机制不能识别2T以后的磁盘空间, 这就是GPT出现的原因

					问题: UEFI, GPT ?

	分区管理工具: fdisk, parted, sfdisk
		fdisk: 对于一块硬盘来说,最多只能管理15个分区
			# fdisk -l [-u] [device...]

			# fdisk device
				子命令: 管理功能
					p: print, 显示已有分区
					n: new, 创建
					d: delete, 删除
					w: write, 写入磁盘并退出
					q: quit, 放弃更新并退出
					m: 获取帮助
					l: 列表所分区id
					t: 调整分区id

			fdisk 分区之后并不会实时生效

			The partition table has been altered!

			Calling ioctl() to re-read partition table.

			WARNING: Re-reading the partition table failed with error 16: 设备或资源忙 
			The kernel still uses the old table. The new table will be used at
			the next reboot or after you run partprobe(8) or kpartx(8)
			正在同步磁盘
			[root@localhost ~]#



			查看内核是否已经识别新的分区:
				cat /proc/partitions

			通知内核重新读取硬盘分区表:
				partx -a /dev/DEVICE
					-n M:N

					[root@localhost ~]# cat /proc/partitions 
					major minor  #blocks  name

					   8        0  125829120 sda
					   8        1     487424 sda1
					   8        2    1952768 sda2
					   8        3   62914560 sda3
					  11        0    1048575 sr0
					[root@localhost ~]# partx -a /dev/sda
					partx: /dev/sda: error adding partitions 1-3  (不用担心这行报错)
					[root@localhost ~]# partx -a /dev/sda
					partx: /dev/sda: error adding partitions 1-6
					[root@localhost ~]# cat /proc/partitions		(不用担心这行报错)
					从这里可以看到新增加的分区sda4,sda5,sda6已经被内核识别了
					major minor  #blocks  name

					   8        0  125829120 sda
					   8        1     487424 sda1
					   8        2    1952768 sda2
					   8        3   62914560 sda3
					   8        4          1 sda4
					   8        5   10485760 sda5
					   8        6   10485760 sda6
					   11        0    1048575 sr0
					[root@localhost ~]# partx -a -n 4:6 /dev/sda
					partx: /dev/sda: error adding partitions 4-6 	(不用担心这行报错)
					[root@localhost ~]# 

				除了partx命令,kpartx也可以完成相同的功能
				
				kpartx -a /dev/DEVICE
					-f: force, 慎用,如果-a不起作用再考虑这个选项


				CentOS 5 系统中没有上面这两个命令, 需要使用partprobe
					partprobe [/dev/DEVICE]

Linux文件系统管理:
	Linux文件系统: ext2, ext3, ext4, xfs, btrfs, reiserfs, jfs, swap
		swap: 交换分区,将磁盘当做虚拟内存使用	
		光盘: iso9660
	Windows: fat32, ntfs
	Unix: FFS(Fast File System), UFS(Unix File System), JFS2(Enhanced Journaled File System)
	网络文件系统: NSF, CIFS
	集群文件系统: GFS2(redhat), OCFS2(oracle)
	分布式文件系统: ceph, 
		moosefs, mogilefs, GlusterFS, Lustre

	根据其是否支持"journal"功能还可分为:
		日志型文件系统: ext3, ext4, xfs, ...
		非日志文件系统: ext2, vfat
		
		对于非日志文件系统, 磁盘中分为mata区和data区,创建文件时先创建meta信息,再去写信息到data区.如果文件写到一半,突然断电了.文件肯定创建失败了,
		系统再次启动的时候需要花费很长的时间去寻找有哪些文件创建失败了,然后删除那些失败的文件.
		所谓的日志功能,就是在磁盘中除了meta区,data区,还有一个journal区. 
		创建文件不是先创建meta信息,而是先将meta信息写到journal去,然后写数据到data区,完成之后将journal区的meta信息复制到meta区.这样如果在写文件的时候
		断电了的话,下次系统启动就不用满世界找创建失败的文件,只需要查查journal区中记录的文件就可以了,大大缩小了查找的范围.系统重启后的恢复时间短.
		但是日志型文件系统也有缺点,因为它在每次文件写入完成之后还有一个要将meta信息从journal区复制到meta区的IO操作,
		所以每次成功写入文件的效率都比非日志文件系统的效率要差一点.不过这点损失比起它带来的优点很小,所以一般都是使用日执行文件系统的.

	文件系统的组成部分:
		内核中的模块: ext4, xfs, vfat
		用户空间的管理工具: mkfs.ext2, mkfs.ext4, mkfs.xfs, mkfs.vfat

	Linux的虚拟文件系统: VFS

	创建文件系统:
		mkfs命令
			-L 'LABEL': 指定卷标, 有了卷标将来就可以使用卷标名来对分区进行调用操作
			-f: 强制
			(1) # mkfs.FS_TYPE /dev/DEVICE
				ext4
				xfs
				btrfs (btree file system)
				vfat

				[root@localhost ~]# mkfs.ext4 -L MYDATA /dev/sda5
				
			(2) # mkfs -t FS_TYPE /dev/DEVICE
				[root@localhost ~]# mkfs -t xfs -f /dev/sda5

		mke2fs: ext系列文件系统专用管理工具
			-t {ext2|ext3|ext4}
			-b {1024|2048|4096} :指定块的大小 blocksize
			-L 'LABEL'
			-j: 相当于 -t ext3
				mkfs.ext3 = mkfs -t ext3 = mke2fs -j = mke2fs -t ext3
			-i #: bytes-per-inode,为数据空间中每多少个字节创建一个inode, 这个大小不应该小于block的大小,
				否则一定会有inode浪费掉meta区和data区的大小比例应该根据需求合理设定.如果meta区很大,data区已经耗尽,meta区还有剩余,
				那么剩余的meta区就浪费了,反之亦然.所以如果要存的文件个数多,内容少,就把meta区设置大一些.
			-N #: number-of-inodes,为数据空间创建多少个inode
			-m #: reserved-blocks-percentage,为管理人员预留的空间占据的百分比, 默认是5
			-O FEATURE[,...]: 启用指定特性
				-: 启用指定特性
				O ^FEATURE: 关闭指定特性

			[root@localhost ~]# mke2fs -b 1024 -m 3 -L MYDATA /dev/sda5

		mkswap: 创建交换分区
			mkswap [options] device [size]

			前提: 调整其分区的ID为82
	
	其它常用工具:
		lsblk: list block devices

		blkid: 块设备属性信息查看
			blkid [OPTION]... [DEVICE]
				-U UUID: 根据指定的UUID查找设备
				-L LABEL: 根据指定的LABEL查找对应的设备

		e2label: 管理ext系列文件系统的LABEL
			# e2lable DEVICE [LABEL]

		tune2fs - adjust tunable filesystem parameters on ext2/ext3/ext4 filesystem.
		: 重新设定ext系列文件系统可调整参数的值
			-l: 查看指定文件系统的超级块信息: super block
			-L 'LABEL': 修改卷标
			-m #: 修改预留给管理员的空间百分比
			-j: 将ext2升级为ext3
			-O [^]feature: 文件系统属性启用或禁用
			-o: 指定文件系统的默认挂载选项
			-U UUID: 修改UUID号

		dumpe2fs: - dump ext2/ext3/ext4 filesystem information.
			-h: 查看超级块信息

	文件系统检测:
		fsck: File System CheCK
			fsck.FS_TYPE
			fsck -t FS_TYPE
				-a: 自动修复错误
				-r: 交互式修复错误
				-f: 强制检查，即使文件系统被标记干净
			
			Note: FS_TYPE一定要与需要检测的文件系统类型相同. 运行命令前要先umount磁盘

			[root@localhost ~]# fsck -t ext4 /dev/sdc1
			fsck from util-linux-ng 2.17.2
			e2fsck 1.41.12 (17-May-2010)
			/dev/sdc1: clean, 30/28112 files, 32521/112420 blocks
			[root@localhost ~]# fsck -f /dev/sdc1
			fsck from util-linux-ng 2.17.2
			e2fsck 1.41.12 (17-May-2010)
			Pass 1: Checking inodes, blocks, and sizes
			Pass 2: Checking directory structure
			Pass 3: Checking directory connectivity
			Pass 4: Checking reference counts
			Pass 5: Checking group summary information
			/dev/sdc1: 30/28112 files (3.3% non-contiguous), 32521/112420 blocks

		e2fsck: ext系列文件专用的检测修复工具
			-y: 自动回答为yes
			-f: 强制修复

回顾: 
	磁盘接口类型,磁盘分区, fdisk, mkfs, mke2fs, tune2fe, blkid, dumpe2fs, e2lable
	
	vfs: xfs, ext{2|3|4}, btrfs

文件系统管理:
	将额外文件系统与根文件系统某现存在的目录建立起关联关系,进而使得此目录作为其它文件访问入口的行为称之为挂载

	解除此关联关系的过程称之为卸载

	把设备关联至挂载点: Mount Point
		mount

	卸载时,可使用设备,也可以使用挂载点
		umount

	注意: 挂载点下的原有文件在挂载完成后会被临时隐藏

	挂载方法: mount DEVICE MOUNT_POINT

		mount: 通过查看/etc/mtab文件显示当前系统已挂载的所有设备,但是不一定准确,因为可以通过-n选项不更新/etc/mtab文件
				而/proc/mounts文件显示的是内核挂载的所有设备,即使你mount -n的设备,也会显示出来

		mount [-fnrsvw] [-t vfstype] [-o options] device dir
			device: 指明要挂载的设备
				(1) 设备文件: 例如:/dev/sda5
				(2) 卷标(LABEL): -L 'LABEL' 例如: -L 'MYDATA'
				(3) UUID, -U 'UUID': 例如: -U 'fc55467a-eaa7-4ed8-8b59-7df4004d16f8'
				(4) 伪文件系统: proc, sysfs, devtmpfs, configfs
			dir: 挂载点
				事先存在, 建议使用空目录
				进程正在使用中的设备无法被卸载
				通过查看/proc/mounts文件可以显示内核正在mount的所有设备
					
			常用选项:
				-t vfstype: 指明要挂载的设备上的文件系统类型,
					(这个选项可以省略,因为mount命令会自动调用blkid查看文件系统的类型)
				-r: readonly, 只读挂载
				-w: read and write, 读写挂载
				-n: 不更新/etc/mtab, 
					mtab是一个文件,默认情况下,mount设备会在这个文件里多一行记录,当unmount时,删除对应记录
				-a: 自动挂载所有支持自动挂载的设备(定义在了/etc/fstab文件中,且挂载选项中有"自动挂载"功能)
				-L 'LABEL': 以卷标格式指定挂载设备
				-U 'UUID': 以UID指定要挂载的设备
				-B --bind: 绑定目录到另一个目录上


			注意: 查看内核追踪到的已挂载的所有设备: cat /proc/mounts

			-o options: (挂载文件系统的选项,上面的选项是mount命令的选项)
				async: 异步模式
				sync: 同步模式
				atime/noatime: 每一次访问目录或文件都会(/不会)更新时间戳
				diratime/nodiratime: 目录的访问时间戳
				auto/noauto: 是否支持自动挂载
				exec/noexec: 是否支持将文件系统上的应用程序运行为进程
				dev/nodev: 是否支持在此文件系统上使用设备文件
				suid/nosuid: 是否支持特殊权限
				remount: 重新挂载
				ro: 只读
				rw: 可读可写
				user/nouser: 是否允许普通用户挂载此设备
				acl: 启用此文件系统上的acl(访问控制列表,access control list)功能

				注意:上述选项可多个同时使用,彼此使用逗号,分隔.
					默认挂载选项: defaults 选项相当于如下所有的选项
						rw, suid,  dev,  exec,  auto,  nouser,  and async.

				[root@localhost ~]# mount -o remount,ro /dev/sdb3 /mydata/

	卸载命令:
		# umount DEVICE
		# umount MOUNT_POINT

		查看正在访问指定文件系统的进程
			# fuser -v MOUNT_POINT

		终止正在访问指定文件系统的进程
			# fuser -km MOUNT_POINT
			在生产环境中慎用这条命令

		[root@localhost ~]# mount
		/dev/mapper/VolGroup-lv_root on / type ext4 (rw)
		proc on /proc type proc (rw)
		sysfs on /sys type sysfs (rw)
		devpts on /dev/pts type devpts (rw,gid=5,mode=620)
		tmpfs on /dev/shm type tmpfs (rw,rootcontext="system_u:object_r:tmpfs_t:s0")
		/dev/sda1 on /boot type ext4 (rw)
		/dev/mapper/VolGroup-lv_home on /home type ext4 (rw)
		none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)
		/dev/sdb3 on /mydata type ext4 (ro)
		[root@localhost ~]# umount /mydata/
		umount: /mydata: device is busy.
		(In some cases useful info about processes that use
		 the device is found by lsof(8) or fuser(1))
		[root@localhost ~]# fuser -v /mydata/
		USER        PID ACCESS COMMAND
		/mydata/:            root       2168 ..c.. bash
		[root@localhost ~]# fuser -km /mydata/
		/mydata/:             2168c
		[root@localhost ~]# umount /mydata/
		[root@localhost ~]# 

	挂载交换分区:
		启用: swapon
			swapon [OPTION]... [DEVICE]
				-a: 激活所有的交换分区
				-p PRIORITY: 指定优先级
		禁用: swapoff [OPTION]... [DEVICE]

	内存空间使用状态:
		free [OPTION]
			-m: 以MB为单位
			-g: 以GB为单位
			什么都不写就是默认,以KB为单位

	文件系统空间占用的信息的查看工具:
		df: disk space available on the file system
			df [OPTION]... DIR 
				-h: human-readable
				-i: inodes instead of blocks
				-P: 以POSIX兼容的格式输出

	查看某个目录总体空间占用状态
		du: disk usage
			du [OPTION]... DIR
				-h: human-readable
				-s: summary

				[root@localhost ~]# du /etc -sh
				39M	/etc

	命令总结: mount, umount, free, df, du, swapon, swapoff, fuser	

文件挂载的配置文件: /etc/fstab
	
	每行定义一个要挂载的文件系统(一共有6列)

	tmpfs                   /dev/shm                tmpfs   defaults        0 0
	devpts                  /dev/pts                devpts  gid=5,mode=620  0 0
	sysfs                   /sys                    sysfs   defaults        0 0
	proc                    /proc                   proc    defaults        0 0
	/dev/sdb3				/mydata					ext4	defaults,acl 	0 0


	要挂载的设备或伪文件系统, 挂载点, 文件系统类型, 挂载选项, 转储频率, 自检次序

		要挂载的设备或伪文件系统:
			设备文件, LABEL(LABEL=""), UUID(UUID=""),伪文件系统名称(proc, sysfs)

		挂载点: MOUNT_POINT

		挂载选项:
			defaults

		转储频率:
			这个字段表示多久备份一次
			0: 不做备份
			1: 每天转储
			2: 每隔一天转储
			
			通常情况下都是0,这个功能现在不常用了

		自检次序: 
			0: 不自检
			1: 首先自检: 一般只有rootfs才用1
			...

文件系统上的其他概念:

	Inode: Index Node, 索引节点
		地址指针:
			直接指针:
			间接指针:
			三级指针: 


		inode bitmap: 对位标识每个inode空闲与否的状态信息
	
	链接文件:
		硬链接:
			不能够对目录进行(应为会循环引用, .和..这两个目录硬链接是文件系统的固有属性.)
			不能跨分区进行(因为寻找inode编号都是在同一分区下查找的)
			本质是同一个inode的多个不同路径: 创建文件的硬链接就是为inode创建新的引用路径,因此会增加其引用计数

		符号链接(软链接):
			可以对目录进行
			可以跨分区
			本质上指向的是另一个文件的路径: 其大小为指向的路径字符串的长度,不会增加或减少目标文件inode的引用计数

		ln -[sv] SRC DEST
			-s: symbolic link
			-v: verbose

			ls -i 可以查看对应的inode编号
			[root@localhost ~]# ll -i f*
			2490521 -rw-r--r--. 2 root root 909 Jan 21 06:59 fstab
			2490521 -rw-r--r--. 2 root root 909 Jan 21 06:59 fstab.hl
			2490531 lrwxrwxrwx. 1 root root   5 Jan 21 07:01 fstab.sl -> fstab
		硬链接中存放的是指针,指向另一个Inode编号,是对另一个inode引用,会增加inode的引用计数,
		所以硬链接和源文件指向相同的Inode.表示这个inode可以有源文件本身和硬链接两条路径都可以寻址出来结果.
		硬链接(fstab.hl)的大小和源文件(fstab)的大小是一样的. 如果删除了源文件,
		还是可以通过硬链接这条路径寻址到相同的编号的inode(和源文件指向的inode编号相同). 
		查询inode编号不能跨分区,所以我们自己创建的硬链接不能跨文件分区.

		软链接中存放的不是指针而是源文件路径的字符串(fstab),不是对另外一个inode的引用,所以inode的引用计数不会增加 
		上面这个例子中软链接fstab.sl的大小是5,不是源文件的大小,而是被链接的文件名称字符串fstab的长度

		当源文件被删除后,还是可以从硬链接的文件查看到内容,而软链接就不行了,因为软链接找不到真正的Inode,而且记录的
		路径也失效了.
			[root@localhost ~]# ll -i f*
			2490521 -rw-r--r--. 2 root root 909 Jan 21 06:59 fstab
			2490521 -rw-r--r--. 2 root root 909 Jan 21 06:59 fstab.hl
			2490531 lrwxrwxrwx. 1 root root   5 Jan 21 07:01 fstab.sl -> fstab
			[root@localhost ~]# rm fstab
			rm: remove regular file `fstab'? y
			[root@localhost ~]# ll -i f*
			2490521 -rw-r--r--. 1 root root 909 Jan 21 06:59 fstab.hl
			2490531 lrwxrwxrwx. 1 root root   5 Jan 21 07:01 fstab.sl -> fstab
			[root@localhost ~]# cat fstab.sl
			cat: fstab.sl: No such file or directory
			[root@localhost ~]# cat fstab.hl
			#
			# /etc/fstab
			# Created by anaconda on Fri Dec 31 05:18:11 2021
			#
			# Accessible filesystems, by reference, are maintained under '/dev/disk'
			# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info
			# 省略其他的内容
			...
			[root@localhost ~]#

		思考: 如何判断一个文件是硬链接还是软链接?
			(1) 可以使用file命令,如果显示为symbolic link, 则为软链接
			(2) ls -l 显示出来的结果, 软链接的文件类型是l, 且后面会有 -> 符号显示了软链接指向的位置
			(3) 还可以通过 ls -il 查看inode编号来判断是否软链接, 软链接和源文件的inode编号不一样.


	文件管理操作对文件的影响:
		文件删除:
		文件复制:
		文件移动:
			如果跨分区移动,那和文件复制差不多
			如果是同分区,那么inode不用变化创建一条新的条目指向原来的inode即可

	练习:
		1. 创建一个20G的文件系统, 块大小为2048, 文件系统ext4, 卷标为TEST,
			要求此分区开机后自动挂载至/testing目录,且默认有acl挂载选项
			(1) 创建20G分区
			(2) 格式化
				mke2fs -t ext4 -b 2048 -L 'TEST' /dev/DEVICE
			(3) 编辑/etc/fstab
				LABEL='TEST' /testing ext4 defaults,acl 0 0


		2. 创建一个5G的文件系统, 卷标HUGE, 要求此分区开机自动挂载至/mogdata目录, 文件系统是ext3

		3. 写一个脚本,完成如下功能
			(1) 列出当前系统识别到的所有磁盘设备
				fdisk -l /dev/[sh]d[a-z] | grep -o "^Disk /dev/[sh]d[a-z]"
			(2) 如果磁盘数量为1, 则显示器空间使用信息,否则显示最后一个磁盘上的空间使用信息
				if [ $disks -eq 1 ]; then 
					fdisk -l /dev/[sh]da; 
				else 
					fdisk -l $(fdisk -l /dev/[sh]d[a-z] | grep -o "^Disk /dev/[sh]d[a-z]" | tail -1 | cut -d' ' -f2)
				fi

bash脚本编程之用户交互:
	read [option]... [name ...]
		-p 'PROMPT': 指定提示信息
		-t TIMEOUT : 超时时间,单位是秒

	bash -n /path/to/some_file
		检查脚本中的语法错误

	bash -x /path/to/some_file
		调试执行
	
	示例:
		#!/bin/bash
		# Version: 0.0.1
		# Author: Mage
		# Description: read testing

		read -p "Enter a disk special file: " diskfile 
		[ -z "$diskfile" ] && echo "please input a parameter." && exit 1

		if fdisk -l | grep "^Disk $diskfile" &> /dev/null; then
			fdisk -l $diskfile
		else
			echo "no such device."
				exit 2
		fi

回顾:
	mount/umount, fstab配置文件, ext文件系统基础原理, read, bash 
		
		/etc/fstab

		ext: super block, GDT, inode table, block bitmap, inode bitmap

		dumpe2fs -h, tune2fs -l

		硬链接
		软链接: l, 

RAID: 
	Redundant Arrays of Inexpensive Disks
	Redundant Arrays of Independent Disks

	Berkeley: A case for Redundant Arrays of Inexpensive Disks RAID

		提高IO能力:
			通过磁盘并行读写
		提高耐用性:
			通过磁盘冗余来实现

		级别: 多块磁盘组织在一起的工作方式有所不同
		RAID实现的方式:
			外接式磁盘阵列: 通过扩展卡提供适配能力
			内接式RAID: 主板集成RAID控制器
			Software RAID: 不推荐在生产环境使用这种方式

	级别: level
		RAID-0: 0, 条带卷, strip
		RAID-1: 1, 镜像卷, mirror
		RAID-2
		...
		RAID-5:
		RAID-6
		RAID10
		RAID01

		RAID-0: (raid控制器)将文件分割成多块(chunk),分散存储在多块硬盘上. 每块硬盘存储整个文件的一部分. 
			读写性能提升
			可用空间: N*min(S1,S2,...)
			无容错能力
			最少磁盘数: 2, 2+

		RAID-1: 将文件分割成多块(chunk), 每块硬盘上都需要存储所有的chunk, 相当于镜像了一块磁盘.
			读性能提升,写性能略有下降
			可用空间: 1*min(S1,S2,....)
			有冗余能力
			最少磁盘数: 2, 2+, 一般来说就用2块

		RAID-4:	3块硬盘组成1个RAID, 前面2个硬盘存储分别的chunk, 第3个盘不存储chunk,只存储校验信息(前面两块盘中,chunk数据做异或操作(^|)的结果). 
		这种模式允许随机的1块磁盘坏掉,可以从剩下的2个硬盘信息中将文件的内容算出来. 但是这种raid有缺陷, 专门用1块硬盘存储校验信息, 
		所有的操作都需要和校验信息打交道,所以存储校验信息的硬盘的访问次数会很集中,这块磁盘的压力会比另外2块硬盘大很多,这就是性能瓶颈.

			chunk1,	chunk2, 校验信息
			1101, 	0110, 	1011
				  	0110

		RAID-5: 避免了RAID-4的痛点, 循环存放chunk和校验信息到所有硬盘中.其他方面和RAID-5一样.
			读写性能提升
			可用空间: (N-1)*min(S1,S2,...)
			有容错能力: 1块磁盘
			最少磁盘数: 3, 3+

		RAID-6: 校验码存2次.
			读写性能提升
			可用空间: (N-2)*min(S1,S2,...)
			有容错能力: 2块磁盘
			最少磁盘数: 4, 4+

		混合类型
			RAID-10:
				读写性能提升
				可用空间: N*min(S1,S2,...)/2
				有容错能力: 每组镜像最多坏一块
				最小磁盘数: 4, 4+
			RAID-01:

			RAID-50

			RAID7

			JBOD: Just a Bunch Of Disks
				功能: 将多块磁盘的空间合并成一个大的连续空间使用
				可用空间: sum(S1,S2,...)

		常用级别: RAID-0, RAID-1, RAID-5, RAID-10, RAID-50, JBOD

		实现方式:
			硬件实现方式
			软件实现方式

			CentOS 6上的软件RAID的实现:
				结合内核中的md(multi devices模块)

				mdadm: 模式化的工具
					命令的语法格式: mdadm [mode] <raiddevice> [options] <component-device>
						支持的RAID级别: LINEAR, RAID0, RAID1, RAID4, RAID5, RAID6, RAID10

					模式:
						创建: -C
						装备: -A
						监控: -F
						管理: -f, -r, -a

					<raiddevice>: /dev/md#
					<component-devices>: 任意块设备

					-C: 创建模式
						-n #, --raid-devices=: 使用#个块设备来创建此RAID
						-l #, --level=: 指明要创建的RAID的级别
						-a {yes|no}, --auto: 自动创建目标RAID设备的设备文件
						-c CHUNK_SIZE, --chunk=: 指明块大小
						-x #, --spare-devices=: 指明空闲盘的个数

						例如: 创建10G可用空间的RAID5

					-D: 显示raid的详细信息
						mdadm -D /dev/md#

					创建一个raid
					# mdadm -C /dev/md0 -a yes -n 3 -x 1 -l 5 /dev/sdb{7,8,9,10}

					管理模式:
						-f, --fail: 标记执行磁盘为损坏
						-a: 添加磁盘
						-r: 移除磁盘

					观察md的状态:
						cat /proc/mdstat

					停止md设备:
						mdadm -S /dev/md#

				watch命令: watch - execute a program periodically, showing ouput fullscreen
					-n #: 刷新间隔,单位是秒

					wathc -n# 'COMMAND'

					使用 Ctrl+c 退出watch命令

		注意: RAID不能替代备份策略, RAID只是让磁盘冗余,使得业务逻辑不会因为磁盘损坏而中断. 如果数据是人为误操作删除的,那么无论怎么RAID都不可能恢复.
		所以该备份的工作一步都不能少.

		练习1: 创建一个可用空间为10G的RAID0设备, 要求其chunk大小为128K,文件系统为ext4,有一个空闲盘,
			开机可自动挂载至/backup
		练习2: 创建一个可用空间为10G的RAID10设备, 要求其chunk大小为256K,文件系统为ext4, 开机可自动挂载至/mydata

LVM2:
	LVM: Logical Volume Manager, Version: 2

	dm: device mapper组件,将一个或多个底层块设备组织成一个逻辑设备的模块
		/dev/dm-#

	LVM的两种命名方式:
	(1) /dev/mapper/VG_NAME-LV_NAME
			/dev/mapper/vol0-root 
	(2) /dev/VG_NAME/LV_NAME 
			/dev/vol0/root

	pv管理工具:
		pvs: 简要pv信息显示
		pvdisplay: 显示pv的详细信息

		pvcreate /dev/DEVICE: 创建pv

	vg管理工具:
		vgs:
		vgdisplay

		vgcreate [-s #[kKmMgGtTpPeE]] VolumeGroupName PhysicalDevicePath [PhysicalDevicePath...]
			-s #[kKmMgGtTpPeE]: 指定PE(physical extend)的大小

		vgextend VolumeGroupName PhyscialDevicePath [PhyscialDevicePath...]
		vgreduce VolumeGroupName PhyscialDevicePath [PhyscialDevicePath...]
			先做pvmove

		vgremove

		[root@localhost yum.repos.d]# vgcreate -s 16M testvg /dev/sdb1 /dev/sdb3
		  Volume group "testvg" successfully created


	lv管理工具
		lvs
		lvdisplay

		lvcreate -L #[mMgGT] -n Name VolumeGroup

		lvremove /dev/VG_NAME/LV_NAME
		删除逻辑卷,快照...

		[root@localhost /]# lvremove /dev/myvg/mylv-snap 
		Do you really want to remove active logical volume mylv-snap? [y/n]: y
		Logical volume "mylv-snap" successfully removed
		[root@localhost /]# 


		[root@localhost yum.repos.d]# lvcreate -L 5G -n mylv testvg
		 Logical volume "mylv" created
		[root@localhost yum.repos.d]# vgs
		 VG     #PV #LV #SN Attr   VSize  VFree 
		 testvg   2   1   0 wz--n- 20.00g 15.00g



	扩展逻辑卷的步骤:
		(1) # lvextend -L [+]#[mMgGtT] /dev/VG_NAME/LV_NAME
		逻辑卷扩展之后,文件系统也需要扩展,不然逻辑卷扩展了,但文件系统还是只能识别扩展前的大小
		使用df -lh 查看
		(2) # resize2fs /dev/VG_NAME/LV_NAME
			resize2fs 是ext类型的文件系统, 不同到的文件系统用的命令不一样

	缩减逻辑卷的步骤:
		# umount /dev/VG_NAME/LV_NAME
		# e2fsck -f /dev/VG_NAME/LV_NAME
		# resize2fs /dev/VG_NAME/LV_NAME #[mMgGtT]
		# lvreduce -L [-]#[mMgGtT] /dev/VG_NAME/LV_NAME
		# mount

	快照: snapshot

		前提: 快照必须要和源卷在同一卷组中,但并不要求和源卷一样大小(取决于你的快照需要存活多久时间,只要源卷
		中变化的数据的量小于快照的大小,快照就还是有用的,一旦超过快照的大小,快照就作废了.)

		快照是LVM的一个特色功能,它和备份不同.快照可以粗略的理解为在创建快照的一瞬间, 快照复制了所有磁盘数据的meta信息,但并不会赋值data信息. 
		相当于创建了meta信息的副本,指向了源数据的inode.快照会监控meta信息,如果meta发生变化,快照会把发生变化的数据data复制一份,
		这样的结果是,快照会保存发生变化的数据,没有变化的数据快照直接访问原来的inode.基于这种机制,快照才能在短时间内记住磁盘的所有信息. 
		快照卷是有大小的,如果在快照之后,数据变化的数量超过了快照的大小,快照也就失效了.

		备份则不同,备份需要复制所有信息,包括meta信息和所有数据的inode.

		lvcreate -L #[mMgGtT] -p r -s -n snapshot_lv_name original_lv_name
			-L #[mMgGtT]: 指定大小
			-p r: 设定权限为只读
			-s: 表示创建snapshot
			-n: 需要创建的snapshot的名字
			
		[root@localhost ~]# lvcreate -s -L 512M -n mylv-snap -p r /dev/myvg/mylv 
		Logical volume "mylv-snap" created
		[root@localhost ~]# mount /dev/myvg/mylv-snap /mnt
		mount: block device /dev/mapper/myvg-mylv--snap is write-protected, mounting read-only

	练习1: 创建一个至少有两个PV组成的大小为20G的名为testvg的VG,要求PE大小为16MB,而后在卷组中创建大小为5G的逻辑卷testlv, 挂载至/users目录
		pvcreate /dev/sdb1
		pvcreate /dev/sdb3
		pvdisplay
		vgcreate -s 16M testvg /dev/sdb1 /dev/sdb3
		lvcreate -L 5G -n mylv testvg
		mkdir /users
		mkfs -t ext4 /dev/testvg/mylv 
		mount /dev/testvg/mylv /users


	练习2: 
	新建用户archlinux,要求其家目录为/users/archlinux,而后su切换至archlinux用户,复制/etc/pam.d目录至自己家目录
		useradd -d /users/archlinux archlinux
		[root@localhost ~]# echo "mageedu" | passwd --stdin archlinux
		[root@localhost ~]# su - archlinux
		[archlinux@localhost ~]$ pwd
		/users/archlinux
		[archlinux@localhost ~]$ cp -r /etc/pam.d .
		[archlinux@localhost ~]$ ll
		total 4
		drwxr-xr-x. 2 archlinux archlinux 4096 Jan 23 08:12 pam.d
		[archlinux@localhost ~]$ 


	练习3: 扩展testlv至7G, 要求archlinux用的文件不能丢失
		[root@localhost ~]# df -lh
		Filesystem					  Size  Used Avail Use% Mounted on
		/dev/mapper/testvg-mylv 	  4.8G   11M  4.6G   1% /users
		[root@localhost ~]# lvextend -L 7G /dev/testvg/mylv 
		[root@localhost ~]# df -lh
		Filesystem					  Size  Used Avail Use% Mounted on
		/dev/mapper/testvg-mylv 	  4.8G   11M  4.6G   1% /users
		[root@localhost ~]# resize2fs /dev/testvg/mylv 
		[root@localhost ~]# df -lh
		Filesystem					  Size  Used Avail Use% Mounted on
		/dev/mapper/testvg-mylv 	  6.8G   12M  6.5G   1% /users
		[root@localhost ~]# 

	练习4: 收缩testlv至3G, 要求archlinux用户的文件不能丢失
		[root@localhost ~]# umount /users
		[root@localhost ~]# e2fsck -f /dev/testvg/mylv 
		[root@localhost ~]# resize2fs /dev/testvg/mylv 3G
		[root@localhost ~]# lvreduce -L 3G /dev/testvg/mylv 
		[root@localhost ~]# mount /dev/testvg/mylv /users
		[root@localhost ~]# ll -a /users/archlinux/ 
		-rw-r--r--. 1 archlinux archlinux  124 Oct 16  2014 .bashrc
		drwxr-xr-x. 2 archlinux archlinux 4096 Jan 23 08:12 pam.d
		[root@localhost ~]# 

	练习5: 对testlv创建快照,并尝试基于快照备份数据,验证快照的功能
		lvcreate -s -L 300M -n mylv-snapshot -p r /dev/testvg/mylv

文件系统挂载使用:
	挂载光盘设备:
		光盘设备文件: 
			如果光盘使用SATA接口: /dev/sr0
			如果光盘使用IDE接口: /dev/hdc

			符号链接文件:
				/dev/cdrom
				/dev/cdrw
				/dev/dvd
				/dev/dvdrw

		mount -r /dev/cdrom /media/cdrom
		umount /dev/cdrom

	dd命令: convert and copy a file. 这是一个底层复制命令,它是操作block的.
		用法: 
			dd if=/PATH/FROM/SRC of=/PATH/TO/DEST
				bs=#: block size, 复制单元大小, 单位是字节
				count=#: 复制多少个bs

				skip=#:跳过多少字节
				seek=#:寻找从头开始的多少字节

			磁盘拷贝:
				dd if=/dev/sda of=/dev/sdb

			备份MBR
				dd if=/dev/sda of=/tmp/mbr.bak bs=512 count=1

			备份MBR分区表
				dd if=/dev/sda of=/data/mybr.bak bs=1 count=64 skip=446

			清除一个磁盘的分区信息(即覆盖掉MBR,慎用这个写法)
				dd if=/dev/zero of=/dev/sda bs=512 count=1

			破坏MBR中的bootloader:
				dd if=/dev/zero of=/dev/sda bs=256 count=1

		两个特殊设备:
			/dev/null: 数据黑洞
			/dev/zero: 吐零机

			示例: 复制一个文件
			[root@localhost ~]# dd if=/etc/fstab of=/tmp/fstab
			1+1 records in
			1+1 records out
			781 bytes (781 B) copied, 0.000115274 s, 6.8 MB/s

			示例: 复制文件中100个字节
			[root@localhost ~]# dd if=/etc/fstab of=/tmp/fstab.2 bs=1 count=100
			100+0 records in
			100+0 records out
			100 bytes (100 B) copied, 0.000215674 s, 464 kB/s
			[root@localhost ~]# cat /tmp/fstab.2

			#
			# /etc/fstab
			# Created by anaconda on Sat Jan 22 09:58:13 2022
			#
			# Accessible filesystems, by ref[root@localhost ~]# 

	博客作业: lvm基本应用,扩展级缩减实现

回顾: lvm2, dd
	lvm: 边界动态扩展或收缩: 快照:
		pv --> vg --> lv
			PE:
			LE:

	dd: 复制

btrfs文件系统
	Btrfs (B-tree, Butter FS, Better FS), GPL, Oralce, 2007, 
	它最重要的特性是CoW(写时复制)
	用来取代/ext3/ext4, xfs

	核心特性:
		(1)多物理卷支持: btrfs可有多个底层物理卷组成:支持RAID:以及联机"添加", "移除", "修改":
		(2)写时复制更新机制(CoW): 复制,更新及替换指针.具体表现为,在修改文件的时候,会先将源文件复制一份出来再修改复制出来的文件,
		最后将指向源文件的指针修改为指向新的文件.这样的好处是,如果你修改错了一个文件,源文件还可以找回来.
		(3)数据及元数据校验码: checksum. 保存数据及元数据的校验码,这样它就可以检查文件是否损坏,如果损坏了会自动尝试修复文件.
		(4)子卷: sub_volume. 可以在一个卷上创建多个子卷,每个子卷可以单独使用和挂载
		(5)快照: 快照就是lvm里面快照的功能.除此之外还支持快照的快照(增量快照)
		(6)透明压缩: 存放时压缩,读取是解压缩,对于上层应用来说这个操作是透明的. 不过压缩和解压缩操作会占用额外的cpu时钟周期

	文件系统创建:
		mkfs.btrfs
			-L: 'LABEL'
			-d <type>: raid0, raid1, raid5, raid6, raid10, single. 指明数据存储时的类型
			-m <profile>: raid0, raid1, raid5, raid6, raid10, single, dup. 指明元数据存储时的类型
			-O <feature>: 在格式化的时候就要开启的特性, 有些功能在老的kernel上不支持
				-O list-all: 列出支持的所有feature

			创建一个btrfs
			[root@localhost ~]# mkfs.btrfs -L 'mydata' /dev/sdb /dev/sdc

		属性查看:
			btrfs filesystem show 
			btrfs filesystem show --mounted
			btrfs filesystem show --all-device
			btrfs filesystem show /dev/sdb 

			btrfs filesystem df: 显示一个已挂载的文件系统的空间使用情况

		挂载文件系统
			mount -t btrfs /dev/sdb MOUNT_POINT

		挂载时开启透明压缩机制:
			mount -o compress={lzo|zlib} DEVICE MOUNT_POINT

	子命令: filesystem, device, balance, subvolume
	博客作业: btrfs管理及应用

		调整文件系统的大小:
			btrfs filesystem resize [+|-]# MOUNT_POINT

			[root@localhost ~]# btrfs filesystem resize max /mydata

			[root@localhost ~]# btrfs filesystem show
			Label: 'mydata'  uuid: 1f29e7d7-c185-4e21-94b0-80c10d4d76b7
				Total devices 2 FS bytes used 916.00KiB
				devid    1 size 20.00GiB used 2.01GiB path /dev/sdb
				devid    2 size 20.00GiB used 2.01GiB path /dev/sdc

			[root@localhost ~]# btrfs filesystem resize -10G /mydata
			Resize '/mydata' of '-10G'
			[root@localhost ~]# btrfs filesystem show
			Label: 'mydata'  uuid: 1f29e7d7-c185-4e21-94b0-80c10d4d76b7
				Total devices 2 FS bytes used 916.00KiB
				devid    1 size 10.00GiB used 2.01GiB path /dev/sdb
				devid    2 size 20.00GiB used 2.01GiB path /dev/sdc

		管理btrfs系统的device:
			btrfs device add DEVICE MOUNT_POINT: 新增加一个设备到已有的btrfs
				[root@localhost ~]# btrfs device add /dev/sdd /mydata/
				上面这条命令中的/dev/sdd其实还没有创建过文件系统, 在add进btrfs的时候会自动格式化为btrfs

			btrfs device delete: 从btrfs中移除一个逻辑卷,与lvm不同的是,btrfs在移除之前会将被移除的逻辑卷内的数据自动移动到别的地方.
				[root@localhost ~]# btrfs device delete /dev/sdb /mydata

			btrfs balance start: 将chunk均匀的分散到组成btrfs的所有设备上
				[root@localhost ~]#  btrfs balance start /mydata/
				WARNING:

					Full balance without filters requested. This operation is very
					intense and takes potentially very long. It is recommended to
					use the balance filters to narrow down the balanced data.
					Use 'btrfs balance start --full-balance' option to skip this
					warning. The operation will start in 10 seconds.
					Use Ctrl-C to stop it.
				10 9 8 7 6 5 4 3 2 1
				Starting balance without any filters.
				Done, had to relocate 3 out of 3 chunks

			btrfs balance start -m:可以改变元数据或者数据(-d)的raid级别,修改之前请一定确认硬盘的数量是否支持要修改的raid级别
				[root@localhost ~]# btrfs balance start -mconvert=raid5 /mydata
				ERROR: error during balancing '/mydata': Invalid argument
				There may be more info in syslog - try dmesg | tail
				[root@localhost ~]# dmesg | tail
				[ 3428.123550] BTRFS info (device sdb): device deleted: /dev/sdb
				[ 3728.961922] BTRFS error (device sdb): unable to start balance with target metadata profile 128
				这里出错是因为当前的btrfs中只有2块硬盘,根本都达不到raid5最少3块硬盘的要求,所以失败. 在添加了一块硬盘后,自然就能成功了
				[root@localhost ~]# btrfs device add /dev/sdb /mydata/
				[root@localhost ~]# btrfs filesystem show /mydata/
				Label: 'mydata'  uuid: 1f29e7d7-c185-4e21-94b0-80c10d4d76b7
					Total devices 3 FS bytes used 724.00KiB
					devid    2 size 20.00GiB used 1.28GiB path /dev/sdc
					devid    3 size 20.00GiB used 1.28GiB path /dev/sdd
					devid    4 size 20.00GiB used 0.00B path /dev/sdb

				[root@localhost ~]# btrfs balance start -mconvert=raid5 /mydata			修改元数据的raid级别
				Done, had to relocate 2 out of 3 chunks
				[root@localhost ~]# btrfs balance start -mconvert=raid5 -dconvert=raid5 /mydata 	修改数据的raid级别
				Done, had to relocate 3 out of 3 chunks
				[root@localhost ~]# 

		管理btrfs系统的子卷:
			btrfs subvolume 
				list MONT_POINT:
				create:
				show MOUNT_POINT: 查看子卷信息
				snapshot: 创建快照
				delete: 删除资源或快照

			创建一个子卷:
				[root@localhost ~]# btrfs subvolume list /mydata
				[root@localhost ~]# btrfs subvolume create /mydata/logs
				Create subvolume '/mydata/logs'
				[root@localhost ~]# btrfs subvolume list /mydata
				ID 266 gen 105 top level 5 path logs
				[root@localhost ~]# 


			创建出来的子卷可以单独挂载
				通过卷名挂载:
					[root@localhost ~]# mount -o subvol=logs /dev/sdb /mnt
				通过子卷的ID挂载(id可以通过show查看):
					[root@localhost ~]# mount -o subvolid=266 /dev/sdb /mnt

			创建快照:
				[root@localhost logs]# btrfs subvolume snapshot /mydata/logs/ /mydata/logs_snapshot
				Create a snapshot of '/mydata/logs/' in '/mydata/logs_snapshot'
				[root@localhost logs]# 
			删除快照:
				[root@localhost logs_snapshot]# btrfs subvolume delete /mydata/logs_snapshot/
				Delete subvolume (no-commit): '/mydata/logs_snapshot'

		将ext文件系统转换为btrfs:
			btrfs-convert DEVICE: 转换文件系统为btrfs,转换前需要umount和fsck

					[root@localhost logs]# btrfs-convert /dev/sdd1
					[root@localhost logs]# btrfs filesystem show
					Label: 'mydata'  uuid: 1f29e7d7-c185-4e21-94b0-80c10d4d76b7
						Total devices 2 FS bytes used 696.00KiB
							devid    2 size 20.00GiB used 2.03GiB path /dev/sdc
							devid    4 size 20.00GiB used 1.03GiB path /dev/sdb

					Label: none  uuid: 0395f43d-de1e-4ef2-88c8-85400bdebbca
						Total devices 1 FS bytes used 228.76MiB
						devid    1 size 5.00GiB used 485.78MiB path /dev/sdd1

					/dev/sdd1原来是ext4,现在变成了btrfs

				-r: 将btrfs系统转换回原来的文件系统,同样先umount

					[root@localhost ~]# btrfs-convert -r /dev/sdd1 
					rollback complete
					[root@localhost ~]# blkid /dev/sdd1
					/dev/sdd1: UUID="fa32da6f-08b3-4d9d-b3de-1c4f8b953b69" TYPE="ext4" 
					[root@localhost ~]# 
	
	压缩,解压缩及归档工具
		
		compress/uncompress: .Z结尾的格式
		gzip/gunzip: .gz
		bzip2/bunzip2: .bz2
		xz/unxz: .xz
		zip/unzip: 
		tar, cpio

		1. gzip/gunzip
			gzip压缩完成后会删除原文件,只保留压缩后的文件, 反之,gunzip在解压之后会删除压缩文件只保留解压出来的文件.

			gzip [OPTION]... FILE ...
				-d,--decompress: 解压缩, 相当于gunzip
				-c: 将结果输出至标准输出,这个选项和重定向组合起来就可以保留源文件.
					gzip -c messages > messages.gz
				-#: 1-9,指定压缩比例

			zcat: 不显示展开压缩文件的前提下,查看压缩文本文件的内容

		2. bzip2/bunzip2/bzcat

			bizp2 [OPTION]... FILE...
				-k: keep, 保留原文件
				-d: 解压缩
				-#: 1-9, 压缩比, 默认为6

			bzcat: 不显示展开压缩文件的前提下,查看压缩文本文件的内容
			相对于gzip来说bzip2的压缩比更高一些.

		3. xz/unxz/xzcat
				
			xz [OPTION]... FILE...
				-k: keep, 保留原文件
				-d: 解压缩
				-#: 1-9, 压缩比, 默认为6

			xzcat: 不显示展开压缩文件的前提下,查看压缩文本文件的内容

		4. tar
			tar [OPTION]...

			(1)创建归档
				tar -c -f /PATH/TO/SOMEFIEL.tar FILE...

				tar -cf /PATH/TO/SOMEFIEL.tar FILE...
					
			(2) 查看归档文件中的文件列表
				tar -t -f /PATH/TO/SOMEFILE.tar

			(3) 展开归档
				tar -x -f /PATH/TO/SOMEFILE.tar
				
				tar -x -f /PATH/TO/SOMEFILE.tar -C /PATH/TO/DIR

			结合压缩工具实现: 归档并压缩
				-j: bzip2, -z: gzip, -J: xz

bash脚本编程
	
	if语句, bash -n, bash -x

	CONDITION:
		bash命令:
			用命令的执行装填结果
				成功: true
				失败: false

			成功或失败的意义:取决于用到的命令

	单分支:
		if CONDITION; then
			if-true
		fi
	
	双分支:
		if CONDITION; then
			if-true
		else
			if-false
		fi
	
	多分支:
		if CONDITION1; then
			if-true
		elif CONDITION2; then
			if-true
		elif CONDITION3; then
			if-true
		...
		else
			all-false
		fi

	示例: 用户键入文件路径, 脚本判断文件类型
		#!/bin/bash
		#
		read -p "Enter a file path: " filename

		if [ -z "$filename" ]; then
			echo "Usage: Enter a file path."
			exit 2
		fi

		if [ ! -e "$filename" ]; then
			echo "No such file."
			exit 3
		fi

		if [ -f $filename ]; then
			echo "A common file."
		elif [ -d $filename ]; then
			echo "A directory."
		elif [ -L $filename ]; then
			echo "A symbolic."
		else
			echo "other file type."
		fi

	注意: if语句可以嵌套	

循环: for, while, until
	循环体: 要执行的代码可能要执行n编
		进入条件:
		退出条件:

	for循环:
		for 变量名 in 列表; do
			循环体
		done

		执行机制:
			依次将列表中的元素赋值给"变量名"; 每次赋值后即执行一次循环体,知道列表中的元素耗尽,循环结束;
		
		示例: 添加10个用户, user1 ~ user10, 密码同用户名
	
	列表生成方式:
		(1) 直接给出列表:
		(2) 整数列表
			(a) {start..end}
			(b) $(seq [start [step]], end)  	
				seq的具体用法可以是用seq --help查看
		(3) 返回列表的命令
			$(COMMAND)
				for file in $(ls /var); do
		(4) glob
				for file in /var/*; do
		(5) 变量引用
				$@, $*  

		示例:
			#!/bin/bash

			declare -i estab=0
			declare -i listen=0
			declare -i other=0

			for state in $(netstat -tan | grep "tcp\>" | awk '{print $NF}'); do
				if [ "$state" == 'ESTABLISHED' ]; then
					let estab++
				elif [ $state == 'LISTEN'  ]; then
					let listen++
				else
					let other++
				fi
			done

			echo "ESTABLISTED: $estab"
			echo "LISTEN: $listen"
			echo "Unknown: $other"

	练习1: /etc/rc.d/rc3.d目录下分别有多个以K开头和以S开头的文件
		分别读取每个文件的文件名,如果文件名以K开头,则输出文件名+Stop,如果文件名以S开头,则输出文件名+Start	
			"K34filename Stop"
			"S66filename Start"
	
	练习2: 写一个脚本, 使用ping命令探测172.16.250.1 ~ 172.16.250.254之间的主机的在线状态.
		ping 命令:
			-c: 指定次数
			-w #: 指定超时时间,单位是秒
		可以使用ping命令的返回值$?来判断是否ping通了其他主机

回顾: btrfs, compress/uncompress, archive, bash

	btrfs:
		子命令: filesystem, device, balance, sub_volume
		管理: 创建,挂载,子卷的创建,子卷的挂载,向btrfs中添加或移除物理设备,重新均衡数据

	压缩/解压缩:
		gzip/gunzip/zcat, bzip2/bunzip2/bzcat, xz/unxz/xzcat, zip/unzip
		tar: -c, -t, -x, -f, -j, -z, -J, -C
	
	bash：
		多分支if语句: for循环

Linux程序包管理:

	API: Application Programming Interface
		POSIX: Portable OS
	
		程序源代码 --> 预处理 --> 编译 --> 汇编 --> 链接 --> 可执行程序
			静态编译: 把程序需要的所有库都编译在一起,编译后的文件就不需要依赖其他库了,但是体积会很大.
			共享编译: .so 
	
	ABI: Application Binary Interface
		Windows与Linux不兼容
		库级别的虚拟化:
			Linux: WINE
			Windows: Cygwin
	
	系统级开发:
		C
		C++
	应用级开发: 
		java
		python
		php
		perl
		ruby
	
	二进制应用程序的组成部分:
		二进制文件,库文件,配置文件,帮助文件

		程序包管理器:
			debian: deb, dpt(包管理器)
			redhat: rpm, rpm(包管理器)
				rpm: Redhat Package Manager
					RPM is Package Manager

			Gentoo:
			Archlinux:

	源代码命名方式: name-VERSION.tar.gz	
		VERSION： major.minor.release
				主版本.次版本.发行版
	rpm包命名方式:
		name-VERSION-.release.arch.rpm
			VERSION: major.minor.源程序的release号
			release.arch:
				release: release.OS
			
			例如:
				zlib-1.2.7-13.el7.i686.rpm
				el7: enter linux 7

			常见的arch:
				x86_64: x64, x86_64, amd64
				x86(i386,i486,i586,i686,这几个没区别,486相对386来说能适用于更高性能的cpu)
				powerrpc: ppc
				跟平台无关: noarch

		
		testapp: 拆包
			假设testapp一共有20个功能,绝大多数的人只会用到其中的15个功能,只有%5的人会用到剩下的那5个功能,这时编译源代码的时候就不知道是否要全都编译.
			拆包的概念因运而生. 一般来说,支包都是需要先安装主包的.
			testapp-VERSION-ARCH.rpm: 主包
			testapp-devel-VERSION-ARCH.rpm: 支包
			testapp-testing-VERSION-ARCH.rpm
		
		包之间: 存在依赖关系
			X, Y, Z

			yum: rpm包管理器的前端工具,它保存了包之间的依赖关系,使你在安装软件的时候免得被包之间的依赖关系而晕头转向
			apt-get: deb包管理器的前端工具
			zypper: suse上的rpm前端管理工具
			dnf: Fedora 22+ rpm管理器前端管理工具
		
		查看二进制程序所依赖的库文件: ldd - print shared library dependencies.
			ldd /PATH/TO/BINARY_FILE
			
		
		管理及查看本机装载的库文件
			ldconfig - configure dynamic linker run-time bindings.
				/sbin/ldconfig -p: 显示本机已经缓存的所有可用库文件名以及文件路径映射关系

				配置文件: /etc/ld.so.conf, /etc/ld.so.conf.d/*.conf
				缓存文件: /etc/ld.so.cache

		程序包管理:
			功能: 将编译的应用程序的各个组成文件打包成一个或多个程序包文件,从而方便快捷的实现程序包的安装,卸载,查询,升级和校验等管理操作.

			1. 程序的组成清单(每个包独有)
				文件清单
				安装或卸载时运行的脚本
			2. 数据库(公共)
				程序包名称及版本
				依赖关系:
				功能说明:
				安装生成的各文件的文件路径及校验信息
		
		安装程序包的方式:
			使用包管理器: rpm
			使用前端工具: yum, dnf
		
		获取程序包的途径:
			(1) 系统发行版的光盘或官方的服务器
				CentOS镜像:
					http://mirrors.aliyun.com
			
			(2) 项目官方站点
			(3) 第三方组织:
				Fedora-EPEL
				搜索引擎:
					http://pkgs.org
					http://rpmfind.net
					http://rpm.pbone.net
			(4) 自己制作

		建议: 检查合法性
			来源合法性:
			程序包的完整性:

	CentOS系统上rpm命令管理程序包:
		安装,卸载,升级,查询,校验,数据库维护

		安装:
			rpm {-i|--install} [install-options] PACKAGE_FILE ...
			-v: verbose
			-vv: verbose more
			-h, --hash: 以#显示程序包管理执行进度,每个#表示%2的进度

			rpm -ivh PACKAGE_FILE ...
				[install-options]
					--test: 测试安装,但不真正执行安装过程: dry run模式
					--nodeps: 忽略依赖关系
					--replacepkgs: 重新安装

					--nosignature: 不检查来源和发行
					--nodigest: 不检查包完整性

					--noscripts: 不执行程序包的脚本片段:
						%pre: 安装前脚本 	--nopre
						%post: 安装后脚本	--nopost
						%preun: 卸载前脚本	--nopreun
						%postun: 卸载后脚本	--nopostun
		
			示例:
			# rpm -ivh  /media/cdrom/RedHat/RPMS/samba-3.0.10-1.4E.i386.rpm	//按路径安装并显示进度
			# rpm -ivh --relocate /=/opt/gaim gaim-1.3.0-1.fc4.i386.rpm    	//指定新的安装目录
			# rpm -ivh --test gaim-1.3.0-1.fc4.i386.rpm						//用来检查依赖关系；并不是真正的安装；

		升级:
       		rpm {-U|--upgrade} [install-options] PACKAGE_FILE ...
			rpm {-F|--freshen} [install-options] PACKAGE_FILE ...
			   upgrade: 安装如果发现有旧版程序包,则"升级", 如果不存在旧版程序包, 则"安装"
			   freshen:	安装如果发现有旧版程序包,则"升级", 如果不存在旧版程序包, 则不执行升级操作

			   rpm -Uvh PACKAGE_FILE ...
			   rpm -Fvh PACKAGE_FILE ...

			   --oldpackage: 降级
			   --force: 强行升级
			
			注意:(1) 不要对内核做升级操作: Linux支持多内核版本并存, 因此,直接安装新版本内核,有问题的话,可以使用旧版本
				(2) 如果原程序包的配置文件安装后曾被修改,升级时,新版本的提供的同一个配置文件并不会直接覆盖老板的配置文件,
				而把新版本的文件重命名(FILENAME.rpmnew)后保留.
			示例:
			# rpm -Uvh --oldpackage gaim-1.3.0-1.fc4.i386.rpm				//新版本降级为旧版本

		查询:
			rpm {-q|--query} [select-options] [query-options]

			[select-options]:
				-a, --all: 所有已安装的程序包
				-f, --file: 查询指定的文件由哪个程序包安装生成,这里查询的文件名称要写绝对路径

				-p, --package /PATH/TO/PACKAGE_FILE: 针对尚未安装的程序包文件做查询操作

				--whatprovides CAPABILITY: 查询指定的CAPABILITY有哪个包所提供
				--whatrequires CAPABILITY: 查询指定的CAPABILITY有哪个包所依赖
			
			[query-options]
				--changelog: 查询rpm包的changelog(不是源程序的changelog)
				-c, --configfiles: 查询程序包的配置文件
				-d, --docfiles: 查询程序的文档
				-i, --info: Display package information, including name, version, and description.
				-l, --list: 查看指定的程序包安装后生成的所有文件列表
				--scripts: 程序包自带的脚本片段
				-R, --requires: 查询指定的程序包所依赖的CAPABILITY
				--provides: 列出指定程序包所提供的CAPABILITY
				--conflicts:

				用法: 
					-qi PACKAGE, -qf FILE, -qc PACKAGE, -ql PACKAGE, -qd PACKAGE
					-qpi PACKAGE_FILE, -qpl PACKAGE_FILE, ...
					-qa 
			示例:
				rpm -qa | grep httpd			#[搜索指定rpm包是否安装]--all搜索*httpd*
				rpm -qf `which yum`				#[搜索rpm包]查询一个命令是由哪个包安装的
				rpm -ql httpd					#[搜索rpm包]--list所有文件安装目录
				rpm -qpi Linux-1.4-6.i368.rpm	#[查看rpm包]--query--package--install package信息
				rpm -qpf Linux-1.4-6.i368.rpm	#[查看rpm包]--file
				rpm -qpR file.rpm 				#[查看包]依赖关系
				rpm2cpio file.rpm |cpio -div    #[抽出文件]

		卸载: 
			rpm {-e|--erase} [--allmatches] [--justdb] [--nodeps] [--noscripts] [--notriggers] [--test] PACKAGE_NAME ...
				
		校验:
			rpm {-V|--verify} [select-options] [verify-options]

				S file Size differs
				M Mode differs (includes permissions and file type)
				5 digest (formerly MD5 sum) differs
				D Device major/minor number mismatch
				L readLink(2) path mismatch
				U User ownership differs
				G Group ownership differs
				T mTime differs
				P caPabilities differ

				[root@localhost Packages]# rpm -V zsh
				S.5....T.    /usr/share/zsh/5.0.2/functions/zmv
			
	包来源合法性验证及完整性验证:
		完整性验证: SHA
		来源合法性验证: RSA

		公钥加密: 
			非对称加密: 加密解密使用同一密钥
			非对称加密: 密钥是成对儿的
				public key: 公钥
				secret key: 私钥

		导入所需要公钥:
			rpm --import /PATH/FROM/GPG-PUBKEY-FILE

			CentOS 7发行版光盘提供的密钥文件: RPM-GPG-KEY-CentOS-7
	
	数据库重建:

		rpm {--initdb|--rebuilddb}
			initdb: 初始化
				如果实现不存在数据库,则新建之,否则,不执行任何操作
			rebuilddb: 重建
				无论当前存在与否,直接重新创建数据库

		CentOS 7中rpm数据库的位置:
			[root@localhost cdrom]# cd /var/lib/rpm
			[root@localhost rpm]# ls
			Basenames     __db.001  __db.003  Group       Name          Packages     Requirename  Sigmd5
			Conflictname  __db.002  Dirnames  Installtid  Obsoletename  Providename  Sha1header   Triggername


		CentOS 7中不允许多个rpm命令同时执行,因为软件的安装有事务的概念.

回顾: Linux程序包管理的实现, rpm包管理器
	rpm命令实现程序管理:
		安装: -ivh, --nodeps, --replacepkgs
		卸载: -e, --nodeps
		升级: -Uvh, -Fvh, --nodeps, --oldpackage
		查询: -q, -qa, -qf, -qi, -qd, -qc, -q --scripts, -q --changelog, -q --provides, -q --requires
		校验: -v

		导入GPG密钥: --import, -K, --nodigest, --nosignature
		数据库重建: --initdb, --rebuilddb

Linux程序包管理(2)

	CentOS: yum, dnf
	
	URL: 

	YUM: 最早是yellowdog公司研发的, Yellowdog Update Modifier

	yum repository: yum repo
		存储了众多rpm包,以及报的相关的元数据文件(放置于特定目录下: repodata)

		文件服务器:
			ftp://
			http://
			nfs://
			file:///		#file://是协议, 最后一个/是根目录

	yum客户端:
		配置文件:
			/etc/yum.conf: 为所有仓库提供公共配置
			/etc/yum.repos.d/*.repo :为仓库的指向提供配置

			man 5 yum.conf: 查看yum配置文件的帮助文档
			
		仓库的定义:
		[repositoryID]
		name=Some name for this repository
		baseurl=url://server1/path/torepository/
				url://server2/path/to/repository/
				url://server3/path/to/repository/

				注意:repodata这个目录所在的目录就应该是仓库指向的地址
		enabled={1|0}
			1表示启用此仓库, 默认为1
		gpgcheck={1|0}
			1表示检查从这个仓库获取的软件包的GPG signature,默认为1
		gpgkey=URL
			指明密钥文件的位置
		enablegroup={1|0}
			是否支持在此仓库上使用group来批量管理程序包,默认为1
		failovermethod={roundrobin|priority}
			故障切换策略,默认是roundrobin
			roundrobin: 随机
			priority: 按照指定的顺序
		username
		password
			有些仓库的访问要求使用用户名,密码登录
		cost: 默认是1000
			
	yum命令的用法:
		yum [options] [command] [package ...]

		command is one of:
        * install package1 [package2] [...]
        * update [package1] [package2] [...]
        * update-to [package1] [package2] [...]
        * update-minimal [package1] [package2] [...]
        * check-update
        * upgrade [package1] [package2] [...]
        * upgrade-to [package1] [package2] [...]
        * distribution-synchronization [package1] [package2] [...]
        * remove | erase package1 [package2] [...]
        * autoremove [package1] [...]
        * list [...]
        * info [...]
        * provides | whatprovides feature1 [feature2] [...]
        * clean [ packages | metadata | expire-cache | rpmdb | plugins | all ]
        * makecache [fast]
        * groups [...]
        * search string1 [string2] [...]
        * shell [filename]
        * resolvedep dep1 [dep2] [...]
           (maintained for legacy reasons only - use repoquery or yum provides)
        * localinstall rpmfile1 [rpmfile2] [...]
           (maintained for legacy reasons only - use install)
        * localupdate rpmfile1 [rpmfile2] [...]
           (maintained for legacy reasons only - use update)
        * reinstall package1 [package2] [...]
        * downgrade package1 [package2] [...]
        * deplist package1 [package2] [...]
        * repolist [all|enabled|disabled]
        * repoinfo [all|enabled|disabled]
        * repository-packages <enabled-repoid> <install|remove|remove-or-reinstall|remove-or-distribution-synchronization> [package2] [...]
        * version [ all | installed | available | group-* | nogroups* | grouplist | groupinfo ]
        * history [info|list|packages-list|packages-info|summary|addon-info|redo|undo|rollback|new|sync|stats]
        * load-transaction [txfile]
        * updateinfo [summary | list | info | remove-pkgs-ts | exclude-updates | exclude-all | check-running-kernel]
        * fssnapshot [summary | list | have-space | create | delete]
        * fs [filters | refilter | refilter-cleanup | du]
        * check
        * help [command]

	显示仓库列表:
        * repolist [all|enabled|disabled]

	显示程序包:
		list
			yum list [all | glob_exp1] [glob_exp2] [...]
			yum list {available|installed|updates} [glob_exp1] [...]
	
	安装程序包:
		install package1 [package2] [...]
        reinstall package1 [package2] [...] (重新安装)
	升级程序包:
		update [package1] [package2] [...]
        downgrade package1 [package2] [...]	(降级)
	检查可用升级包
        check-update
	卸载程序包
        remove | erase package1 [package2] [...]
	查看程序包information:
		info [...]
	查看指定的特性(可以是某个文件)是有哪个程序包提供的
        provides | whatprovides feature1 [feature2] [...]
	清理本地缓存:
        clean [ packages | metadata | expire-cache | rpmdb | plugins | all ]
	构建缓存:
		makecache
	搜索:
        search string1 [string2] [...]
		以指定关键字搜索程序包名及summary信息
	查看指定包所依赖的capabilities
         deplist package1 [package2] [...]
	查看yum事务历史:
        history [info|list|packages-list|packages-info|summary|addon-info|redo|undo|rollback|new|sync|stats]
		事务是指: 软件的安装,升级,卸载. 
	安装及升级本地程序包(现在已经不常用了,直接用yum install 就行)
        localinstall rpmfile1 [rpmfile2] [...]
         (maintained for legacy reasons only - use install)
        localupdate rpmfile1 [rpmfile2] [...]
         (maintained for legacy reasons only - use update)
	包组管理的相关命令:
		groupinstall group1 [group2] [...]
        groupupdate group1 [group2] [...]
        grouplist [hidden] [groupwildcard] [...]
        groupremove group1 [group2] [...]
        groupinfo group1 [...]
        search string1 [string2] [...]

	如何使用光盘当做本地yum仓库:
		(1) 挂载钢盘值某个目录,例如:/media/cdrom
			# mount -r -t iso9660 /dev/cdrom /media/cdrom
		(2) 创建配置文件
			[CentOS7]
			name=
			baseurl=
			gpgcheck=
			enabled=
	
	yum的命令行选项:
		--nogpgcheck: 禁止进行gpg check
		-y: 自动回答为yes
		-q: 静默模式
		--disablerepo=repoidglob:本次命令执行时,临时禁用此处指定的repo
		--enabledrepo=repoidglob:本次命令执行时,临时启用此处指定的repo
		--noplugins: 禁用所有插件

	yum的repo配置文件中可用的变量:
		$releasever: 当前OS的发行版的主版本号
		$arch: 平台
		$basearch: 基础平台
		$YUM0-$YUM9: 用户可以自定义的变量

		http://mirrors.mageedu.com/centos/$releasever/$basearch/os

	创建yum仓库:
		createrepo [options] <directory>

	程序包编译安装:
		testapp-VERSION-release.src.rpm --> 安装后,使用rpmbuild命令制作成二进制格式的rpm包,然后再安装.

		源代码 --> 预处理 --> 编译(gcc) --> 汇编 --> 链接 --> 执行

		源代码组织格式:
			多文件: 文件中的代码之间,很可能存在跨文件依赖关系

			C,C++: make (config --> Makefile.in --> makefile)
			java: maven
		

			编译安装三步骤:
				./configure
					(1) 通过选项传递参数,指定启用特性,安装路径等: 执行时会参考用户的指定以及Makefile.in文件生成makefile
					(2) 检查依赖到的外部环境:
				make
					根据makefile文件,构建应用程序:
				make install

			开发工具:
				autoconf: 生成configure脚本
				automake: 生成Makefile.in

			建议: 安装前查看INSTALL,README

		开源程序源代码的获取:
			官方的自建站点:
				apache.org(ASF)
				mariadb.org
				...
			代码托管:
				SourceForge
				Github.com
				code.google.com
			
		c/c++: gcc (GUN C Complier)

		编译C源代码:
			前提: 提供开发工具及开发环境
				开发工具: make, gcc
				开发环境: 开发库,头文件
					glibc: 标准库

				通过"包组"提供开发组件
					CentOS 6: "Develoment Tools", "Server Platform Development"

			第一步: configure脚本
				选项: 指定安装位置,指定启用的特性
				
				--help: 获取其支持使用的选项
					选项分类:
						安装路径设定:
							--prefix=/PATH/TO/SOMEWHERE: 指定默认安装路径, 如果没有指定,那么默认的目录是/usr/local/
							--sysconfdir=/PATH/TO/SOMEWHERE: 配置文件的安装位置

							System types: 交叉编译的时候使用的配置

							Optional Features: 可选特性
								--disable-feature
								--enable-FEATURE[=ARG]
							
							Optional Packages: 可选包
								--with-PACKAGE[=ARG]
								--without-PACKAGE
			
			第二步: make

			第三步: make install

		安装后的配置:
			(1) 导出二进制程序目录到PATH环境变量中
				编辑文件/etc/profile.d/NAME.sh
					export PATH=/PATH/TO/BIN:$PATH
			(2) 导出库文件路径
				编辑文件/etc/ld.so.conf.d/NAME.conf
					添加新的库文件所在的目录至此文件中:
					/usr/local/apache2/lib 
				让系统重新生成缓存:
					ldconfig [-v]
			(3) 导出头文件
				基于链接的方式实现
				ln -sv 
			(4) 导出帮助手册
				编辑/etc/man.config文件
					添加一个MANPAT

	练习:
		1. yum的配置和使用: 包括yum repository的创建
		2. 编译安装apache 2.2; 启动此服务
	
	博客作业: 程序包管理: rpm/yum/编译


回顾: yum, 源代码编译安装
	
	yum [OPTION]... COMMAND [args]...
		install, list, remove, update, groupinstall, grouplist, clean, makecache
	
	源代码编译:
		前提: 开发环境
			./configure
			make
			make install

Linux网络属性管理
	
	局域网: 以太网, 令牌环网
		Ethernet: CSMA/CD(载波侦听多路检测)
			冲突域
			广播域

			MAC: Media Access Control地址
				48bit: 
					前24bit: 一个组织来分配,厂商来购买
					后24bit: 厂商自己分配

			IP: Internet Protocol
				Routing protocol
				Routed protocol

	OSI, TCP/IP
		tcp/ip分层:
			应用层			application layer
			传输层			transport layer
			网络层			internet layer
			数据链路层		datalink layer
			物理层			physical layer

		传输层协议:
			tcp, udp, sctp, icmp

		网络层协议:
			ip

			ostf

		ip协议:
			IPv4地址分类:
				点分十进制:0-255
				0000 0000 - 1111 1111

				0.0.0.0 - 255.255.255.255

				A类: 
					最左侧的一段是网络地址,后面3段是主机地址
					最左侧的一段地址的最左一位固定是0,其余的位数不限定
					0 000 0000 ~ 0 111 1111: 1 ~ 127
					网络数: 共有126个, 127网段是回环网段
					每个网络中的主机数: 2^24-2 (16777216-2)个主机地址
					默认子网掩码: 255.0.0.0
					私网地址: 10.0.0.0/8

					私网地址无法直接连接互联网,需要使用网络地址转换(Network Address Translator,NAT)
					或者代理服务器(proxy server)来实现.与公网IP相比,私有IP是免费的,同时节省了IP地址资源,
					适合在局域网使用

				B类:
					最左侧的2段是网络地址,固定是10开头,其余的位数不限定
					10 00 000 ~ 10 11 1111: 128 ~ 191
					网络数: 2^14 个
					每个网络中的主机数: 2^16-2 (65534)个主机地址
					默认子网掩码: 255.255.0.0
					私网地址: 172.16.0.0/16 ~ 172.31.0.0/16

				C类:
					最左侧的3段是网络地址,固定是110开头,其余的位数不限定
					110 0 0000 ~ 110 1 1111: 192 ~ 223
					网络数: 2^21
					每个网络中的主机数: 2^8-2 (254)个主机地址
					默认子网掩码: 255.255.255.0
					私网地址: 192.168.0.0/24 ~ 192.168.255.0/24

				D类: 组播
					1110 0000 ~ 1110 1111: 224 ~ 239

				E类:
					240 ~ 255 
				
			子网掩码:
				问题: 172.16.100.100/16是否和172.17.1.1在同一个网段?
				172.16.100.100			172.17.1.1
			&	255.255.0.0			&	255.255.0.0
			------------------		-----------------
				172.16.0.0				172.17.0.0

				所以这两个地址不在同一个网段.
				
				跨网络通信: 路由
					主机路由
					网络路由
					默认路由
	
	将Linux主机接入到网络中:
		IP/mask
		路由: 默认网关
		DNS服务器
			主DNS服务器
			次DNS服务器
			第三DNS服务器

		配置方式:
			静态指定:可以使用以下的4类方法
				(1)ifcfg: ifconfig, route, netstat
				(2)ip: object {link, addr, route}, ss, tc
				(3)配置文件
				(4) CentOS 6:
						system-config-network-tui命令 (setup命令)
					CentOS 7:
						nmcli, nmtui
			动态分配:
				DHCP: Dynamic Host Configuration Protocol

		配置网络接口:
			接口命名方式:
				CentOS 6:
					以太网: eth[0,1,2,...]
					ppp: ppp[0,1,2,...]

			ifconfig命令: IFACE指的是网卡的名字,比如eth0, ens33
				ifconfig [interface]
					# ifconfig -a
					# ifconfig IFACE [up|down]
						up:启用网卡
						down:关闭网卡
       			ifconfig interface [aftype] options | address ...
				   	# ifconfig IFACE IP/mask [up]: 设定ip地址,这里的mask代表的是掩码长度,如果要写地址,得用netmask选项
					   	ifconfig eth0 172.16.100.12/16
					# ifconfig IFACE IP netmask MASK
						ifconfig eth0 172.16.100.11 netmask 255.255.0.0	
					注意: ifconfig命令是立即生效的,但不是永久的,想要永久,就去该配置文件. 
						所以当你添加了一个临时的ip地址在本机的网卡上,然后又想删除它,只需要禁用那个网卡地址就可以了
						[root@master ~]# ifconfig ens33:1 192.168.109.201 netmask 255.255.255.0 up		//给网卡新增一个ip地址
						[root@master ~]# ifconfig ens33:1 down		//删除刚才网卡新增一个临时ip地址



				
					启用或禁用混杂模式: [-] promisc

			route命令: 显示或管理路由表
				路由管理命令,如果有非本地网络的主机想访问本机,就需要有路由.
					查看: route -n
					添加: route add
						route add  [-net|-host] target [netmask Nm] [gw Gw] [[dev] If]
							gw: 网关
							dev: 一般是本地网卡
						
						网关(Gateway)又称网间连接器、协议转换器。网关在传输层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。
						网关的结构也和路由器类似，不同的是互连层。网关既可以用于广域网互连，也可以用于局域网互连。 网关是一种充当转换重任的计算机系统或设备。
						在使用不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，网关是一个翻译器。
						与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。

						练习1: 添加主机路由
						假设我们现在要访问目标主机:192.168.1.3, 经由的网关:172.16.0.1(本地网关不可以使用与本机不在同一路由的地址)
						# route add -host 192.168.1.3 gw 172.16.0.1 dev eth0
						练习2: 添加网络路由
						目标: 192.168.0.0 网关:172.16.0.1
						# route add -net 192.168.0.0 netmask 255.255.255.0 gw 172.16.0.1 dev eth0
						或者
						# route add -net 192.168.0.0/24  gw 172.16.0.1 dev eth0
						练习3: 添加默认路由
						默认路由, 网关: 172.16.0.1
						# route add -net 0.0.0.0 netmask 0.0.0.0 gw 172.16.0.1
						或者
						# route add default gw 172.16.0.1

					删除: route del
						route  [-v] [-A family] del [-net|-host] target [gw Gw] [netmask Nm] [metric N] [[dev] If]
						删除主机路由 目标: 192.168.1.3 网关:172.16.0.1
						# route del -host 192.168.1.3
						删除网络路由 目标: 192.168.0.0 网关:172.16.0.1
						# route del -net 192.168.0.0 netmask 255.255.255.0
						删除默认路由
						# route del -net 0.0.0.0 netmask 0.0.0.0

				DNS服务器指定
					配置文件:/etc/resolv.conf
								nameserver DNS_SERVER_IP1
								nameserver DNS_SERVER_IP2
								nameserver DNS_SERVER_IP3
					正向解析: FQDN --> IP  
						# dig -t A FQDN
						# dig -t A www.baidu.com
						# host -t A FQDN
						dig - DNS lookup utility.
					发向解析: IP --> FQDN
						# dig -x IP
						# dig -x 8.8.8.8
						# host -t PTR IP

						FQDN:完全限定域名(完全合格域名), 例如: www.magedu.com

			netstat命令: 网络状态查看命令
				netstat - Print network connections, routing tables, interface statistics, masquerade connections, and multicast memberships.

				显示网络连接:
				netstat  [--tcp|-t]  [--udp|-u]  [--raw|-w]  [--listening|-l]  [--all|-a] [--numeric|-n] [--extend|-e[--extend|-e]] [--program|-p]
					-t: tcp协议相关
					-u: udp协议相关
					-w: raw socket
					-l: 处于监听状态
					-n: 不反向解析,即以数字形式显示ip地址和端口
					-e: 扩展格式
					-p: 显示相关的进程及PID
					-a: 表示所有连接

					常用组合:
						-tan, -uan, -tnl, -unl

				显示路由表:
					netstat {--route|-r} [--numeric|-n] 
						-r: 显示内核路由表
						-n: 数字格式显示
				
				显示统计数据:
					netstat {--interfaces|-I|-i} [iface] [--all|-a] [--extend|-e]  [--verbose|-v]  [--program|-p]  [--numeric|-n]  
					
					[root@localhost ~]# netstat -i
					[root@localhost ~]# netstat -Ieth0		//注意:I选项后面没有空格
					Kernel Interface table
					Iface       MTU Met    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg
					eth0       1500   0    14936      0      0      0      734      0      0      0 BMRU
					[root@localhost ~]# 

		总结: ifcfg家族命令配置
			ifconfig/route/netstat
			ifup/ifdown

Linux网络配置(2)

	配置Linux网络属性: ip命令

		ip命令:
			ip - show / manipulate routing, devices, policy routing and tunnels

			ip [ OPTIONS ] OBJECT { COMMAND | help }

				OBJECT := { link | addr | route }

			OBJECT:
				ip link -network device Configuration
					set
						dev IFACE
						可设置属性:
							up/down: 激活或禁用指定接口
						# ip link set eth0 up
						# ip link set eth0 down
					show
						[dev IFACE]: 指定接口
						[up]: 仅现实处于激活状态的接口
						
				ip address - protocol address management
					ip addr { add | del } IFADDR dev STRING
						[label LABEL]: 添加地址时指明网卡别名
						[scope {global|link|host}]: 指明作用域
							global: 全局可用
							link: 仅链接可用
							host: 本机可用
						[broadcast ADDRESS]: 指明广播地址
					# ip addr add 172.16.100.13/16 dev eth0
					注意:如果网卡(eth0)上本来就有一个地址, ip addr add命令不会覆盖已有的地址,它会附加一个地址到接口(网卡)上,即一块网卡有2个IP地址

					ip address show - look at protocol address
						[dev DEVICE]
						[label PATTERN]
						[primary and secondary]

					ip address flush - flush protocol address, 清空地址
						使用格式同show

				ip route -routing table management
					ip route add
						添加路由: ip route add TARGET via GW dev IFACE src SOURCE_IP
							TARGET:
								主机路由: IP
								网络路由: NETWORK/MASK
						# ip route add 192.168.1.3 via 172.16.0.1 dev eth0
						# ip route add 192.168.0.0/24 via 172.16.0.1 dev eth0
						添加网关: ip route add default via GW dev IFACE

					ip route delete
						删除路由: ip route del TARGET 
						# ip route del 192.168.1.3
						# ip route del 192.168.0.0/24

					ip route show
					ip route flush
						[dev IFACE]
						[via PERFIX]
			
			ss命令: another utility to investigate sockets.(用来替代netstat,因为效率高)
				格式: ss [OPTIONS]... [FILTER]
					选项: 
						-t: tcp协议相关
						-u: udp协议相关
						-w: 裸套接字相关
						-x： Unix sock相关
						-a: 所有
						-n: 数字格式
						-p: 相关的程序及PID
						-e: 扩展的信息
						-m: 内存用量
						-o: 计时器信息
						
						FILTER := [state TCP-STATE] [EXPRESSION]
				TCP常见状态:
					tcp finite state machine:
						LISTEN: 监听
						ESTABLISHED:
						FIN_WAIT_1
						FIN_WAIT_2
						SYN_SENT
						SYN_RECV
						CLOSED
					EXPRESSION:
						dport=
						sport=
						示例: '(dport=:ssh or sport=:ssh)'	
				常用组合:
					-tan, -tanl, -tanlp, -uan

					# ss -tan
					# ss -tan state ESTABLISTED
					# ss -tanl
					# ss -o state established ’( dport = :ssh or sport = :ssh )’
					# ss -o state fin-wait-1 ’( sport = :http or sport = :https )’ dst 193.233.7/24

Linux 网络属性配置(3): 修改配置文件
	IP, MASK, GW, DNS相关配置文件: /etc/sysconfig/network-scripts/ifcfg-IFACE
	路由相关的配置文件: /etc/sysconfig/network-scripts/route-IFACE 这个文件默认是不存在的,需要自己手动创建.
	DNS配置文件 /etc/resolv.conf

	/etc/sysconfig/network-scripts/ifcfg-IFACE 所支持的参数
		DEVICE:此配置文件应用到的设备,这个字段的值应该和文件名称中的IFACE保持一致
		TYPE: 接口类型,常见的有Ethernet, Bridge
		UUID: 设备的唯一标识
		ONBOOT: 在系统启动时是否激活此设备.
		NM_CONTROLLED: NM是NetworkManager的简写,此网卡是否接受NM控制.在CentOS6中建议为no,貌似它还功能不完全,不支持桥接模式...
		BOOTPROTO:激活此设备时使用的地址配置协议, 常用的是dhcp,static,none,bootp
		HWADDR:对应设备的MAC地址

		如果BOOTPROTO的值是static或者none,那么还需要以下配置
			IPADDR:指明IP地址
			NETMASK: 子网掩码
			GATEWAY: 默认网关
			DNS1: 第一个DNS服务器其指向, 这里配置的DNS信息比在/etc/resolv.conf中配置的DNS优先级高
			DNS2：第2个DNS服务器指向
				在这里能配置DNS,为什么还要可以在/etc/resolv.conf文件中配置DNS? 
				因为/etc/resolv.conf文件,普通用户是不能修改的,而ifcfg-eth0文件,在必要的时候是允许普通用户是有权限修改的.
		USERCTL:普通用户是否可控制此设备.
		PEERDNS:如果BOOTPROTO的值是"dhcp",设置是否允许dhcp server分配的dns服务器信息直接覆盖至/etc/resolv.conf文件中.

		如果需要配置文件立即生效,需要重启网络服务
		# servie network restart
		相当于执行了 /etc/rc.d/init.d/network restart

		[root@localhost network-scripts]# cat ifcfg-eth0 
		DEVICE=eth0
		TYPE=Ethernet
		UUID=699b1d53-3d34-4316-945c-776abd09c11d
		ONBOOT=yes
		NM_CONTROLLED=yes
		BOOTPROTO=dhcp
		HWADDR=00:0C:29:48:66:79
		DEFROUTE=yes
		PEERDNS=yes
		PEERROUTES=yes
		IPV4_FAILURE_FATAL=yes
		IPV6INIT=no
		NAME="System eth0"

	/etc/sysconfig/network-scripts/route-IFACE
		两种风格: 这两种风格不能混合使用,要么都用第一种,要么都用第2种
			(1)TARGET via GW
				192.168.0.0/24 via 172.16.0.1
			(2)每3行定义一条路由信息
				ADDRESS#=TARGET
				NETMASK#=子网掩码
				GATEWAY#=网关地址

				ADDRESS0=192.168.20.0
				NETMASK0=255.255.255.0
				GATEWAY0=172.16.0.1
				ADDRESS1=192.168.30.0
				NETMASK1=255.255.255.0
				GATEWAY1#=172.16.0.1

	给网卡配置多个地址:
		ifconfig:
			ifconfig IFACE_ALIAS 
				ifconfig eth0:0 192.168.0.22/24 up
		ip:
			ip addr add
		配置文件:
			ifcfg-IFACE_ALIAS 例如: /etc/sysconfig/network-scripts/ifcfg-eht0:0
				DEVICE=IFACE_ALIAS
				删除掉HWADDR,UUID等唯一标识网卡的字段
				GATEWAY也删掉,因为一般来说一块网卡对应一个网关,如果你真的有其他网关也可以配置
				其他字段向平常一样填写

		注意:网卡别名不能使用dhcp协议分配 
	
	Linux网络属性配置的tui(text user interface)
		system-config-network-tui
		也可以使用setup找到

		注意:这个工具会修改配置文件,生效需要重启网络服务
	
	配置当前主机的主机名称:
		hostname [HOSTNAME]
			当前环境有效,重启系统后会失效

		配置文件:/etc/sysconfig/network 	不同的发行版位置不一样,centos在这里
		这个配置文件的内容如下:
			NETWORKING=yes				这个字段是整个系统接入网络的开关,如果这里是no,那么无论你怎么配置网络都不会接入网络.所以要确保这里是yes
										貌似我做了这个实验,NETWORKING=no,还是能用ssh连接上,机器也能访问外网.
			HOSTNAME=www.magedu.com
		
	网络接口识别并命名相关的udev配置文件:
		/etc/udev/rules.d/70-persistent-net.rules文件中记录了网卡名称eth0和MAC地址的对应关系.
		
		卸载网卡驱动
			# modprobe -r e1000
		加载网卡驱动
			# modprobe e1000

		[root@localhost rules.d]# cat 70-persistent-net.rules 
		# This file was automatically generated by the /lib/udev/write_net_rules
		# program, run by the persistent-net-generator.rules rules file.
		#
		# You can modify it, as long as you keep each rule on a single
		# line, and change only the value of the NAME= key.

		# PCI device 0x8086:0x100f (e1000)
		SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", ATTR{address}=="00:0c:29:48:66:79", ATTR{type}=="1", KERNEL=="eth*", NAME="eth0"

		有的时候你有2个网卡,但是你想对调eth0和eth1就可以在这里修改配置文件. 
		注意: 配置文件生效需要重启系统,如果你不想重启系统,可以从内核中卸载网卡驱动在重新加载

	CentOS 7 网络属性配置
		传统命名: 以太网eth[0,1,2,...]

		可预测功能
			udev是系统在用户空间探测内核通过sys接口所输出的硬件设备并可以配置硬件设备的应用程序
			udev支持多种不同的命名方案:
				Fireware, 拓扑结构, 
		
		(1)网卡命名机制
			systemd对网络设备的命名方式:
				(a)如果Firmware或者BIOS为主板上集成的设备提供的索引信息可用,且可预测,则根据次索引进行命名. 例如: eno1
				(b)如果Firmware或BIOS为PCI-E扩展槽所提供的索引信息可用,且可预测,则根据此索引进行命名. 例如ens1
				(c)如果硬件接口的物理位置信息可用,则根据此信息进行命名. 例如enp2s0
				(d)如果用户显式启用,也可根据MAC地址进行命名, enx2387a1dc56
				(e)如果以上的所有都不可用,则使用传统命名机制

				上述命名机制中,有的需要biosdevname程序的参与
		
		(2)	名称组成格式
			en: ethernet
			wl: wlan
			ww: wwan

			名称类型:
				o<index>: 集成设备的设备索引号. o是onboard的意思. eth0
				s<slot>: 扩展槽的索引号. s是slot. 	ens33
				x<MAC>: 基于MAC地址的命名. x是MAC
				p<bus>s<slot>: enp2s1

		网卡设备的命名过程:
			第一步:
				udev, 辅助工具程序/lib/udev/rename_device, /usr/lib/udev/rules.d/60-net.rules
			
			第二步: 如果第一步没有执行,则尝试这一步
				biosdevname程序会根据/usr/lib/udev/rules.d/71-biosdevname.rules定义的规则命名网卡设备.

			第三步: 如果前两步都没执行,才尝试这一步
				通过检测网络接口设备,根据/usr/lib/udev/rules.d/75-net-description.rules中的某些参数的值来命名.
					这些参数有: ID_NET_NAME_ONBOARD, ID_NET_NAME_SLOT, ID_NET_NAME_PATH 	
					我查看了CentOS7下的这个文件,但是没看到这些参数,可能是打开的姿势不对.
			如果以上3步都没执行,那么就不会重命名网卡设备,原来叫什么名字还叫什么名字
		
		回归传统方式命名:
			(1) 创建或编辑/etc/default/grub配置文件, 添加net.ifnames=0的配置
				GRUB_CMDLINE_LINUX="net.ifnames=0 rhgb quiet"	
			
			(2) 为grub2生成器配置文件
				grub2-mkconfig -o /etc/grub2.cfg

			(3) 重启系统
		
		地址配置工具: nmcli
			nmcli [OPTIONS...] {help | general | networking | radio | connection | device | agent | monitor} [COMMAND]
             [ARGUMENTS...]

				device - show and manage network interfaces
				conncetion - start, stop, and manage network connection

			如何修改IP地址等属性:
				# nucli connection modify IFACE [+|-]setting.property value
					setting.property: +是新增,-是删除,什么都不写就是修改当前的配置 
						ipv4.addresses
						ipv4.gateway
						ipv4.dns1
						ipv4.method
							manual
			

		nmtui: 文本图形化的配置工具

		主机名称配置工具: hostnamectl
			status
			set-hostname

博客作业: 上述所有内容
	ifcfg， ip/ss, 配置文件, nmcli

参考资料: http://www.redhat.com/hddocs 中的网络管理指南
课外作业: nmap, ncat, tcpdump

网络客户端工具:
	lftp, ftp, lftpget, wget
		lftp - Sophisticated file transfer program
		# lftp [-p port] [-u user[,password]] SERVER
			子命令:
				get: 下载1个文件
				mget: 下载多个文件
				ls
				help

		# lftp URL: 直接下载一个文件

		# ftp 是以前的ftp命令,没有lftp好用. 比如:没有路径补全...

		# wget 
			wget [option]... [URL]...
				-O: 指定保存位置
				-q: 静默下载,通常用在脚本中
				-i file: 指定一个文件,文件中保存需要下载的多个URL
				-c: 断点续传 
				--limit-rate=amount: 设定本次下载使用多大的带宽
					--limit-rate=20K
				-r: 设定重新尝试的次数,如果下载失败.

回顾: ip命令, ss命令, 配置文件: CentOS 7
	ifcfg, ip, netstat, ss
	配置文件:
		/etc/sysconfig/network-scripts/目录下
			ifcfg-IFNAME:网卡的配置文件
			route-IFNAME:路由的配置文件
		/etc/resolv.conf: DNS配置文件
	CentOS 7: nmcli, nmtui

Linux进程及作业管理

	内核的功用: 进程管理,文件系统,网络功能,内存管理,驱动程序,安全管理

	Process: 运行中的程序的一个副本.
		存在生命周期
	
	Linux内核存储进程信息的固定格式: task struct
		多个任务的task struct组成的链表: task list

	进程创建:
		init:
			父子关系进程
			进程: 都由其父进程创建
				fork(), clone(),

		进程优先级:
			0~139:
				1~99:实时优先级,数字越大优先级越高,不需要我们手动处理.
				100~139: 静态优先级,数字越小优先级越高.

				Nice值:
					-20~19
			Big O
				O(1), O(logn), O(n), O(n^2), O(2^n)
		
		进程内存:
			Page Frame:页框, 用存储页面数据
				存储page

				MMU: Memory Management Unit

		IPC: Inter Process Communication, 进程间通信
			同一主机上:
				singal
				shm: shared memory
				semaphor
			不同主机上:
				rpc: remote procedure call
				socket:
	
	Linux内核: 抢占式多任务

		进程类型:
			守护进程: daemon,在系统引导过程中启动的进程,跟终端无关的进程
			用户(前台)进程: 跟终端相关, 通过终端启动的进程
				注意: 也可以把在前台启动的进程送往后台,以守护模式运行.
		
		进程状态:
			运行态: running
			就绪态: ready
			睡眠态:
				可中断: interruptable
				不可中断: uninterruptable
			停止态: 暂停与内存中,但不会被调度,除非手动启动之, stopped
			僵死态: zombie

		进程的分类:
			CPU-Bound: cpu密集型
			IO-Bound: IO密集型
		
		<<Linux内核涉及与实现>>,<<深入理解Linux内核>>

Linux进程查看及管理的工具: pstree, ps, pidof, pgrep, top, htop, glance, pmap, vmstat, dstat, kill, pkill, job, bg, fg, nohup

	pstree命令:
		pstree - display a tree of processes
	
	ps: process state
		ps - report a snapshot of the current processes.

		Linux系统各进程的相关信息均保存在/proc/PID目录下的各文件中:
		
		ps [OPTION]...
			选项: 支持两种风格(System和BSD,Unix的嫡出和庶出)

			常用组合: aux
				u: 以用户为中心,组织进程状态信息显示
				a: 与终端相关的进程
				x：与终端无关的进程

				# ps aux	
				USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
				root          1  0.0  0.0  19364  1536 ?        Ss   Jan28   0:00 /sbin/init
				root          2  0.0  0.0      0     0 ?        S    Jan28   0:00 [kthreadd]

				VSZ: Virtual memory SiZe, 虚拟内存集(线性内存集)
				RSS: Resident Size, 常驻内存集.所谓常驻就是指进程的一些数据或信息,因为当前进程随时可能会被CPU执行,这些信息不能放在磁盘或者交换分区中,
					是要随时待命的.	虚拟内存集一般都比常驻内存集大.
				TTY: 表示通过哪个终端启动的,如果显示为?,表示与终端无关
				STAT: 进程状态
					R: running
					S: interruptable sleeping
					D: uninterruptable sleeping
					T: stopped 
					Z: zombie

					+: 前台进程
					l: 多线程进程
					N: 低优先级进程
					<: 高优先级进程
					s: session leader,

				START:进程的启动时间
				TIME: 表示进程占据CPU的时长
				COMMAND: 由哪个命令运行起来的当前进程
				更多的column解释,可以在man page中找到.
			常用组合: -ef
				-e: 显示所有进程,相当于a和x组合起来
				-f: 显示完整格式的进程信息

			常用组合: -eFH
				-F: 显示完整格式信息和额外的信息
				-H: 以进程层级格式显示进程相关信息

			常用组合: -eo, axo
				-o:用户自定义格式
				-eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,comm
        		axo stat,euid,ruid,tty,tpgid,sess,pgrp,ppid,pid,pcpu,comm

					ni: Nice值
					pri: priority,优先级
					psr: processor, CPU,运行在哪个CPU上
					rtprio: 实时优先级


				[root@localhost ~]#  ps axo pid,psr,command | head -5
				PID PSR COMMAND
				  1   0 /sbin/init
				  2   1 [kthreadd]
				  3   0 [migration/0]
				  4   0 [ksoftirqd/0]

		pgrep, pkill: - look up or signal processes based on name and other attributes.
			pgrep [options] pattern
			pkill [options] pattern
				pattern: 可以是正则表达式

				-U uid: effective user
				-u uid: real user
				-t terminal: 与指定终端相关的进程
				-l: 显示进程名
				-a: 显示完整格式的进程名
				-P pid: 显示父进程为此处指定的进程的子进程列表
		
				[root@localhost ~]# pgrep ssh -l
				1776 sshd
				3232 sshd
				3259 sshd

		pidof:
			根据进程名称获取其PID
				[root@localhost ~]# pidof sshd
				3259 3232 1776

		
		top:
			有许多内置命令:
				排序:
					P:以占据CPU百分比
					M:以占据内存百分比
				首部信息显示:
					uptime信息: l命令
					tasks及cpu信息: t命令
						cpu分别显示: 1(数字按键1)
					memory信息: m命令

				退出top的命令: q
				修改刷新时间间隔: s
				杀死指定进程(根据PID): k

			选项:
				-d #: 指定刷新时间间隔, 默认为3秒
					# top -d 1
				-b: 以批次的方式显示
				-n #: 显示多少批次


			top - 15:43:05 up 2 days,  1:51,  2 users,  load average: 0.00, 0.01, 0.05
				15:43:05表示当前系统时间: up 2days, 1:51表示系统运行了多少时间: 2 users表示当前有2个用户登录了系统
				load average(平均负载): 过去1分钟, 过去5分钟, 过去15分钟 
				使用按键l可以切换是否显示以上的这行信息
			Tasks: 152 total,   2 running, 150 sleeping,   0 stopped,   0 zombie
				task信息:当前系统中的进程数量,以及各种状态中的进程数量.
				task信息和下面的CPU信息合起来是一个模块,可以使用按键t,来切换是否显示这个模块
			%Cpu(s):  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
				us:表示用户空间占用的百分比
				sy:表示内核空间占用的百分比
				ni:表示Nice值,调整Nice值占据的百分比
				id:表示空闲
				wa:表示wait,等待IO完成的时间. ***这一项数据很重要,如果这个数值很高,说明CPU花在等待IO上的时间太多了,意味着你的磁盘太慢了,是系统的瓶颈所在.
				hi:硬中断, CPU用来处理硬中断时间的百分比
				si:软中断, 用来进行模式切换(用户态,内核态),占据的百分比
				st: stolen, 被虚拟化技术偷走的时间占据的百分比. 如果在一台物理机上使用虚拟机虚拟很多东西,虚拟机就会偷走一些时间. 
				CPU的信息,可以使用数字1这个按键切换显示总的信息和各个cpu核心的信息.
					下面这段信息是分散显示每个CPU核心的信息.数字1按键可以在这两种状态之间切换显示CPU信息
					%Cpu0  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
					%Cpu1  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
					%Cpu2  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
					%Cpu3  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
					在CentOS 7中,当你在分散显示CPU信息的时候,再按下t键,就会以进度条的形式分散显示所有CPU的信息,显示进度的形式有两种,|或者柱状图
					%Cpu0  :  15.6/84.4  100[||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||]
					%Cpu1  :   0.0/0.0     0[                                                                                                    ]
					%Cpu2  :   0.0/0.0     0[                                                                                                    ]
					%Cpu3  :   0.0/0.0     0[                                                                                                    ]
			KiB Mem :  4028432 total,  3323404 free,   247484 used,   457544 buff/cache
				物理内存信息: 总量, 空闲, 已用, buff/cache
			KiB Swap:  2097148 total,  2097148 free,        0 used.  3473160 avail Mem 
				交换区的总量, 空闲, 已用, 可用的物理内存大小
				以上的两行也是一个模块,可以使用按键m切换是否显示
					和上面的CPU信息类似,在CentOS 7中可以使用m按键以进度条的方式显示内存信息
					KiB Mem : 13.9/4028432  [||||||||||||||                                                                                      ]
					KiB Swap:  0.0/2097148  [                                                                                                    ]

			  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                       
			38803 root      20   0  108100    620    516 R  99.7  0.0  28:09.75 dd                                                                            
				1 root      20   0  193696   6844   4104 S   0.0  0.2   0:06.85 systemd                                                                       
				2 root      20   0       0      0      0 S   0.0  0.0   0:00.10 kthreadd
			这些是进程信息,
				PR: 优先级
				NI: Nice值
				VIRT: 虚拟内存集
				RES: 常驻内存集
				SHR: 共享内存大小
				S: 表示进程的状态
				%CPU: cpu占比
				%MEM: 内存占比
				TIME+: 进程的累积运行时长
				COMMAND: 启动此进程的命令
			
			top命令显示的进程的信息默认根据CPU占用率倒序显示,
				切换到按内存使用排序,按M键.
				切换到占用CPU时间排序,按T键

		htop命令: htop默认是没有安装的,它的安装文件在EPEL(Extra Packages for Enterprise Linux)源里
			选项:
				-d #:指定刷新时间间隔
				-u UserName: 进现实指定用户的进程
				-s COLUMN: 以指定字段进行排序
			命令:
				s: 跟踪选定进程的系统调用
				l: 显示选定进程打开的文件列表
				a: 将选定的进程绑定至某指定CPU核心
				t: 显示进程树
				h: 显示帮助菜单
			htop的显示比top要好很多,这个命令对于内核参数的调优很重要,需要花时间去熟悉它. 这个程序内部自带帮助菜单

回顾:
	Linux基础
		CPU: timeslice
		Memory: 线性地址
		I/O: 
			分时复用
	进程查看工具: pstree, ps, pgrep, pidof, top, htop

Linu进程查看及管理(2)
	Linux进程查看及管理的工具: pstree, ps, pidof, pgrep, top, htop, glance, pmap, vmstat, dstat, kill, pkill, job, bg, fg, nohup

	vmstat命令: - report virtual memory statistics.
		vmstat [options] [delay [count]]
		选项:
			-s: 显示内存的统计数据

		[root@localhost ~]# vmstat
		procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
		r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
		3  0      0 3263956   2116 512148    0    0     1     0   35   19  0  1 99  0  0

		procs: 显示运行队列和阻塞队列
			r: 等待运行的进程队列的个数(长度). 对于一个单核心的CPU来说,如果等待的个数超过3个,意味着CPU的性能有点低了.
					如果是多核心的比如24核心,那这个数字超过20也算正常
			b: 处于不可中断睡眠态的个数(被阻塞的队列的长度).阻塞一般是由不可中断睡眠导致的,有可能是在等待I/O完成.
		memory:
			swpd:交换内存的使用总量
			free:空闲物理内存总量
			buff:用于buffer的内存总量
			cache:用于cache的内存总量
		swap:
			si: 数据进入到swap的速率(kb/s)
			so: 数据离开到swap的速率(kb/s)
		io: 在块层,io的换进换出的频度
			bi: 从块设备读入设备到系统的速率(kb/s)
			bo: 保存数据值块设备的速率(kb/s)
		system:系统相关
			in: interrupts, 中断速率(个数/秒)
			cs: context switch,上下文切换的速率,其实就是进程切换速率(单位是秒)
		cpu:
			us:用户空间占用cpu的时间比例
			sy:内核空间占用cpu的时间比例
			id:空闲
			wa:等待IO完成所消耗的时间比例
			st:stolen,被虚拟化技术偷走的时间比例

	
	pmap命令: 
		pmap - report memory map of a process

			pmap [options] pid [...]
				-x: 显示详细格式的信息
			
			另外一种实现:
				# cat /proc/pid/maps
		
	glances命令: 这个命令也是在EPEL源里的
		glances - A cross-platform curses-based system monitoring tool.
		内建命令: 可以通过h获取帮助菜单

		常用选项:
			-b: 以Byte为单位显示网卡数据速率
			-d: 关闭磁盘I/O模块
			-f /path/to/somefile:设定输出文件的位置和格式
			-o {HTML|CSV}: 输出格式
			-m: 禁用mount模块
			-n: 禁用网络模块
			-t #: 指定刷新间隔时间
			-1: 每个CPU的相关数据单独显示

		C/S模式下运行glances命令:
			服务模式:
				glances -s -B IPADDR

				IPADDR: 指明监听于本机的哪个地址(一块网卡可能有多个地址)
			客户端模式:
				glances -c IPADDR

				IPADDR: 要连入的服务器地址

	dstat命令: 这是vmstat的替代工具
		dstat -versatile tool for generating system resource statistics.
		dstat [-afv] [options..] [delay [count]]
			选项:
				-c: 显示CPU相关信息
					-C #,#,...total
				-d: 显示disk相关信息:
					-D total,sda,sdb,...
				-g: 显示page相关统计数据
				-m: 显示memory相关统计数据
				-n: 显示network相关统计数据
				-p: 显示process相关统计数据
				-r: 显示io请求相关的统计数据
				-s: 显示swapped相关的统计数据

				--tcp:
				--udp:
				--unix:
				--raw: 裸套接字
				--socket: 相当于tcp,udp,unix一起

				--ipc: 进程间通信

				--top-cpu: 显示最占用CPU的进程
				--top-io: 显示最占用cpu的I/O进程,这一数据对于检查系统瓶颈很有用,
				--top-mem: 显示最占用内存的进程
				--top-lantency: 显示延迟最大的进程
					top系列有很多,查看man page.

	kill命令:
		向进程发送控制信号,以实现对进程管理

		显示当前系统可用信号:
			# kill -l
			# man 7 signal

			常用信号:
				1) SIGHUP: 无序关闭进程而让其重新加载配置文件,但是并不是所有的进程都可以做这件事,比如监听端口的进程就不能再不关闭的情况下修改其监听的端口.
				2) SIGINT: 终止正在运行的进程,相当于Ctrl+c
				9) SIGKILL: 杀死正在运行的进程
				15) SIGTERM: 终止正在运行的进程
				18) SIGCONT: continue
				19) SIGSTOP:

			指定信号的方法:
				(1) 信号的数字标识: 1,2,9...
				(2) 信号的完整名称: SIGHUP
				(3) 信号的简写名称: HUP(就是完整名称去掉前面的SIG)

		向进程发信号:
			kill [-SIGNAL] PID...

		终止"名称"之下的所有进程:
			killall [-SIGNAL] Program
				# killall -15 httpd

	Linux的作业控制

		前台作业: 通过终端启动,且启动后一直占据终端
		后台作业: 可以通过终端启动,但启动后即转入后台运行(释放终端)

		如何让作业运行与后台?
			(1) 对于运行中的作业
				Ctrl+z
			(2) 对于尚未启动的作业
				# COMMAND &

			此类作业虽然被送往后台运行,但其依然与终端相关: 如果希望送往后台,剥离与终端的关系:
				# nohup COMMAND &

				nohup - run a command immune to hangups, with output to a non-tty.

			查看所有作业:
				# jobs
				jobs - Display status of jobs.

			作业控制:
				# fg [[%]JOB_NUM]: 把指定的后台作业调回前台
				# bg [[%]JOB_NUM]: 让送往后台的作业在后台继续进行
				# kill [%JOB_NUM]: 终止指定的作业. Note: 这里的%不能省略,不然JOB_NUM会被认为是PID.
	
	进程的优先级调整:
		静态优先级: 100 ~ 139

		进程默认启动时的nicd值为0,优先级为120

		nice命令: 调整一个准备启动的进程的nice值
			nice - run a program with modified scheduling priority.
			nice [OPTION] [COMMAND [ARG]...]

		renice命令: 修改一个正在运行的进程的nice值
			renice [-n] priority pid...

		查看:
			ps axo pid,comm,ni

	未涉及到的命令: sar, tsar, iostat, iftop
		sar - Collect, report, or save system activity information.
		tsar是淘宝自己开发的一个采集工具,主要用来收集服务器的系统信息(如cpu,io,mem,tcp等)，以及应用数据(如squid haproxy nginx等).
		iostat - Report Central Processing Unit (CPU) statistics and input/output statistics for devices and partitions.
		iftop - display bandwidth useage on an interface by host.

	博客作业: 进程管理工具top/htop/glances/dstat的使用

Linux任务计划,周期性任务执行

	未来的某个时间点执行一次任务: at, batch
	周期性运行某任务: cron

	电子邮件服务:
		smtp: simple mail transmission protocol, 用于传送邮件
		pop3: Post Office Protocol
		imap4: Internet Mail Access Protocol

		mailx - send and receive Internet mail
			
			MUA: Mail User Agent

			发送邮件:
				mailx [-s 'SUBJECT'] username[@hostname]
					邮件正文的生成:
						(1) 直接给出, 最后用Ctrl+d结束
						(2) 输入重定向
						(3) 通过管道:
							echo -e "How areyou?\nHow old are you?" | mail

			查看邮箱:
				mailx
					通过数字指定要看的邮件
					q表示退出邮箱

	at命令:
		
		at [option] TIME
			
			TIME:
				HH:MM [YYYY-mm-dd]
				noon, midnight, teatime
				tomorrow
				now+#{minutes,hours,days,weeks}

			at命令可以直接定义一个任务,用Ctrl+d结束编辑..
				[root@localhost ~]# at now+10minutes
				at> ls -al ~
				at> echo "hello"
				at> <EOT>				//这里按下了ctrl+d
				job 2 at Mon Jan 31 16:04:00 2022
				[root@localhost ~]#


			常用选项:
				-q QUEUE:
				-l: 列出指定队列中等待运行的作业:相当于atq
				-d: 删除指定的作业,相当于atrm
				-c: 查看具体作业任务
				-f /path/from/somefile: 从指定的文件中读取任务

			注意: 作业的执行结果以邮件的形式通知给相关用户

	batch命令:
		让系统字型选择空闲时间去执行此处指定的任务,一般不太使用这个命令了,都用at
	
	周期性任务计划: cron
		
		相关的程序包:
			cronie: 主程序包,提供了crond守护进程及相关辅助工具
			cronie-anacron: cronie的补充程序, 用于监控cronie任务执行状况. 如果cronie中的任务再过去应该运行的时间点没有正常运行,则anacron会随后启动一次这个任务
			crontabs: 包含CentOS提供系统维护任务

			确保crond守护进程处于运行状态:
				CentOS 7:
					# systemctl status crond
				CentOS 6:
					# service crond status
				
		计划要周期性执行的任务提交给crond,有其来实现到点运行.任务的执行结果也是通过mail发送个用户的.
			任务分为两类:
			(1)系统cron任务, 系统维护作业
				通过编辑/etc/crontab文件,来添加作业
			(2)用户cron任务
				使用crontab命令
					# crontab -e
					# crontab -l 	//列出任务
					# crontab -r 	//清空任务

				系统cron任务:
					[root@localhost ~]# cat /etc/crontab 
					SHELL=/bin/bash
					PATH=/sbin:/bin:/usr/sbin:/usr/bin
					MAILTO=root

					# For details see man 4 crontabs

					# Example of job definition:
					# .---------------- minute (0 - 59)
					# |  .------------- hour (0 - 23)
					# |  |  .---------- day of month (1 - 31)
					# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
					# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
					# |  |  |  |  |
					# *  *  *  *  * user-name  command to be executed

					例如: 每天晚上9点10分运行echo命令
						10 21 * * * gentoo /bin/echo "nihao"	//请注意这里的命令最好写绝对路径,因为cron的PATH很少,写绝对路径可以避免不必要的任务执行失败

					时间表示法:
						(1) 特定值:
							给定时间点有效取值范围内的值
						(2) *
							给定时间点上有效取值范围内的所有值
							表示"每..."
						(3) 离散的取值: ,
							#,#,#
						(4) 连续取值: -
							#-#
						(5) 在指定时间范围上,定义步长
							/#: #即为步长
							*/3 * * * *: 表示每3分钟
							20-50/3 * * * *:表示每个小时的20至50分钟内的每3分钟

					例如: 每3小时执行echo命令
						* */3 * * * root /bin/echo "haha" 	//这个不对,这表示每3小时的每一分钟都执行echo命令
						当大的范围使用"每...", 更小的范围要明确指定某个点
						0 */3 * * * root /bin/echo "haha"	//这个才是表示每3小时的第0分钟执行echo命令

				用户cron任务:
					crontab命令定义任务,每个用户都有专用的cron任务文件: /var/spool/cron/USERNAME

					crontab命令:
						crontab [-u user] [-l | -r | -e] [-i]
							-l: 列出所有任务
							-e: 编辑任务
							-r: 移除所有任务
							-i: 同-r一同使用,以交互式模式让用户有选择的移除指定任务

							-u USERNAME: 进root可运行, 有root代替其他用户管理任务.

					注意:
						在用户任务的表达式中就不用写username这一列了
						* */5 * * * /bin/echo "用户自定义任务不用写username这个字段"

						运行的结果以邮件通知给相关用户,如果你十分确定你的任务肯定不会出错,不想收到邮件可以使用以下2种方式.
							(1) COMMAND > /dev/null
							(2) COMMADN &> /dev/null

							对于cron任务表达式, %有特殊用途: 如果在命令重要使用%,则需要转义(\%), 不过如果把%放置于单引号中,也可以不用转义

					思考:
						(1) 如何在妙计被运行任务?
							* * * * * for min in 0 1 2; do echo "hi"; sleep 20; done			//每20秒钟运行一次
						(2) 如何实现每7分钟运行一次任务?


						sleep命令:
							sleep NUMBER[SUFFIX]...
								
								SUFFIX: 
									s: 秒, 默认
									m: 分
									h: 小时
									d: 天

				练习: 
					1. 每4小时备份一次/etc目录至/backup目录中,保存的文件名称格式为"etc-yyyy-mm-dd-HH.tar.xz"
						0 */1 * * * tar -cJf etc-`date +%Y-%m-%d-%H`.tar.xz /etc/ 			#呵呵,运行出错, tar的时候出错了,解决办法是放在脚本里面,定时运行脚本
					2. 每周2,4,7备份/var/log/messages文件至/logs目录中,文件名形如"messages-yyyymmdd"
					3. 每两个小时取出当前系统/proc/meminfo文件中以S或M开头的信息追加至/tmp/memeinof.txt文件中
					4. 工作日时间内, 每小时执行一次"ip addr show"命令

回顾: 进程管理工具,任务计划
	
	进程管理工具: pmap, glances, vmstat, dstat, kill, jobs, bg, fg, nice, renice, pidof, ps, pstree
	任务计划:
		一次性执行某个任务: at, batch
		周期性执行某个任务: crond --> anacron
			* * * * * COMMAND 

	
CentOS 5和6的启动流程
	
	Linux: kernel+rootfs

		kernel: 进程管理, 内存管理, 网络管理, 驱动程序, 文件系统, 安全功能
		rootfs: 就是根文件系统
			glibc

		库: 函数集合, function, 调用接口
			过程调用: procedure
			函数调用: function

		程序

		内核设计流派:
			单内核设计: Linux
				把所有功能集成于同一个程序
			微内核设计: Windows, Solaris
				每种功能使用一个单独子系统实现

		Linux内核特点:
			支持模块化: .ko(kernel object)
			支持模块的动态加载和装载

			组成部分:
				核心文件: /boot/vmlinuz-VERSION-release
					ramdisk(基于内存的磁盘,这个组件是一个非必要的组件,但是在很多场景中都会用到这个组件)
						CentOS 5: /boot/initrd-VERSION-release.img
						CentOS 6: /boot/initramfs-VERSION.img
					ramdisk在CentOS 5上是模拟成硬盘的,而到了CentOS 6上的时候被模拟成了文件,因为模拟成文件可以有效的提高效率.
					Note: ramdisk后面的VERSION-release必须与内核的VERSION-release完全匹配才能被使用
				模块文件: /lib/modules/VERSION-release


				思考: ramdisk是什么? ramdisk为什么是非必要的?
				首先我们要知道一个基本的流程,kernel的作用是加载rootfs,然后启动init进程,然后kernel的基本工作就完成了,系统就算启动了.
				假如说我们现在有1个主机,主机上面有一块硬盘,在硬盘上的存放了kernel和根文件系统(rootfs),当我们的操作系统启动的时候,会先加载kernel,
				让kernel先控制一切,由kernel来负责启动用户空间.当kernel启动以后, kernel要去加载rootfs, 此时,rootfs在主机的某块硬盘上的某个位置. 
				kernel需要先驱动硬盘才能访问硬盘上的数据. kernel中可能并不包含硬盘的驱动(为了使得kernel更简洁,内核做了模块化设计,有可能硬盘的驱动被做成了模块,
				这种情况下,内核中是没有相应的硬盘驱动的). 这里就会产生一个死循环,内核要访问硬盘必须得先加载驱动,而驱动可能被做成了模块,模块文件是在根文件系统上,
				根文件系统存储在硬盘上, 所以内核要加载驱动又得先访问硬盘. 这种情况下是没办法成功启动系统的. 对于这个"鸡生蛋,蛋生鸡"的问题,有两种解决方案
					(1) 把硬盘驱动都编译进kernel, 这样对于个人用户来说可以使用. 但是对于linux的发行版来说,客户的硬盘千差万别,各种各样的硬盘都有,
					无法预先知道客户使用那种硬盘,如果把市面上所有的硬盘的驱动全部编译进kernel,这显然和内核设计精巧的设计原则背道而驰,付出的代价过大而且效率不高.
					所以这种方案不好.
					(2) 借助于外在的辅助机制,比如我们在其他的主机上制作一个微型的根文件系统,这个系统中只包含了能够访问特定种类的硬盘的驱动
					和其他一些最基础的文件系统之类的. 这个微型的根文件系统被制作成单独的一个文件,这个文件的类型是本地回环设备(把一个文件当做硬盘来使用).
					在开机的时候,kernel和这个特殊的文件被加载进内存中的同一个目录下. kernel先加载这个微型的根文件系统,因为这个微型的根文件系统中包含了硬盘的驱动,
					所以kernel就能访问硬盘了. 但是请注意, 这个微型的根文件系统存放的是哪一种硬盘的驱动呢? 它存放的并不是所有的硬盘种类的驱动,如果存放所有种类硬盘的驱动,
					那么这个微型的根文件系统就不"微型"了. 这个文件系统中只存放了适用于当前用户的硬盘驱动. 这个文件系统不是预先制作好的,
					而是用户在安装操作系统时的最后一步由安装程序用工具生成出来的.用户能将操作系统成功安装到主机上,那么安装程序是肯定能够识别主机的硬盘具体型号,
					也就能知道具体应该使用哪种硬盘的驱动,只要将识别出来的硬盘类型的驱动包含进微型的根文件系统中就可以了.
					这里就解释了为什么ramdisk不是必须的原因,如果kernek本身就能识别硬盘,安装程序就不用生成这个辅助的微型根文件系统了.
					这个辅助工具就叫ramdisk,也就是临时的根文件系统.
				当kernel能后读取硬盘之后,会去找真正的rootfs,然后做根切换.


					[root@localhost ~]# ll -h /boot/vmlinuz-2.6.32-504.el6.x86_64 
					-rwxr-xr-x. 1 root root 4.0M Oct 14  2014 /boot/vmlinuz-2.6.32-504.el6.x86_64

					[root@localhost ~]# du -sh /lib/modules/2.6.32-504.el6.x86_64/
					107M	/lib/modules/2.6.32-504.el6.x86_64/
	
	CentOS 系统启动流程:
		
		POST: 加电自检
			ROM: CMOS
				BIOS: Basic Input and Output System

				ROM+RAM

		BOOT Sequence:
			按次序查找各引导设备,第一个有引导程序的设备即为本次启动用到的设备

			bootloader: 引导加载器, 它是一个程序, 加载器就是找到操作系统所在的磁盘分区,把内核加载至内存中,并且还能把控制权转交给内核的程序.
				window: ntloader
				Linux:
					LILO: LInux LOader
					GRUB: Grand Uniform Bootloader
						GRUB 0.X: GRUB Legacy
						GRUB 1.x: GRUB 2
						grub分为grub legacy和grub2, grub2是重新写的和grub1完全不是一个东西. 但他们两使用的设计理念是一致的.
						grub2很强大的一个原因是它突破了MBR中只能使用446个字节做bootloader的限制.
				功能: 提供给一个菜单,允许用户选择要启动的系统或不同的内核版本.把用户选定的内核装载到内存中的特定空间中,解压缩,展开, 并把系统控制权移交给内核.
	
			MBR:
				446 字节: bootloader
				64: fat, 文件系统分区表
				2: 55AA

			GRUB: GRUB把自己的启动过程分成3个阶段(1阶段,1.5阶段,2阶段).
			 	bootloader: 1st stage, 第1阶段位于MBR中, 它什么也不做,它的主要目的就是为了找到硬盘上的stage 2

					1.5 stage: 这个阶段也是在磁盘分区上的, 它帮助GRUB去识别硬盘分区上的文件系统.
						这个1.5阶段也有上面类似kernel启动的死循环问题. 
						文件系统的驱动在磁盘分区上,而此时第1阶段还在bootloader上,又面临要访问文件系统得先加载驱动,而驱动在磁盘分区上,
						要访问磁盘分区又得先知道分区用的是哪个文件系统.
						解决方案也类似,在操作系统成功安装的时候,文件系统的类型就已经确定下来了,
						GRUB的安装程序就把与当前文件系统匹配的1.5阶段安装到了MBR后面的几个扇区中,所以第1阶段安装完之后,
						随后的几个扇区中的中存放的grub1.5阶段文件肯定有可以识别第2阶段文件系统的驱动,从而能够顺利的访问第2个stage.

				disk: 2nd stage

		Kernel:
			自身初始化:
				探测可识别到的所有硬件设备
				加载硬件驱动程序(这一步有可能会借助于ramdisk加载驱动)
				以只读方式挂载根文件系统(只读是为了方式有程序bug,比如删除/目录,当所有程序工作正常,根文件系统会自动以可读可写的方式重新挂载一次)
				运行用户空间的第一个应用程序 /sbin/init


				init程序的类型:
					SysV: init, CentOS 5
						配置文件: /etc/inittab

					Upstart: init, CentOS 6
						配置文件: /etc/inittab, /etc/init/*.conf

					Systemd: systemd, CentOS 7
						配置文件: /usr/lib/systemd/system, /etc/systemd/system

				ramdisk: 

					内核中的特性之一: 使用缓冲和缓存来加速对磁盘文件的访问
						
						ramdisk --> ramfs

						CentOS 5: initrd, 	工具程序:mkinitrd
						CentOS 6: initramfs, 工具程序: mkinitrd, dracut

			系统初始化:
				POST --> BootSequence(BIOS) --> Bootloader(MBR) --> kernel(ramdisk) --> rootfs(只读) --> init(或者systemd, 根据发行版变化) 


		/sbin/init
			
			CentOS 5:
				
				运行级别: 为了系统的运行或维护等应用目的而设定

					0-6: 7个级别
						0: 关机
						1: 单用户模式(root,无须登录), single, 维护模式
						2: 多用户模式, 会启动网络功能,但不会启动NFS, 维护模式
						3: 多用户模式,正常模式,文本界面
						4: 预留级别: 可桶级别
						5: 多用户模式,正常模式,图形界面
						6: 重启

					默认级别: 
						3 或者 5

					切换级别:
						# init #
						或者修改配置文件

					查看级别:
						runlevel
						who -r

						[root@localhost ~]# runlevel
						N 3								// 这里显示的上次的级别和当前的级别,N表示安装系统后还没有改过级别.

			配置文件: /etc/inittab
				
				这个文件有4个字段组成,每一行定义一种action以及与之对应的process

					id:runlevel:action:process
						action:
							wait
							respawn
							initdefault
							sysinit
							...

				接下来我们解释inittab文件中的各个部分
					# inittab       This file describes how the INIT process should set up
					#               the system in a certain run-level.

					id:3:initdefault:

					# System initialization.
					si::sysinit:/etc/rc.d/rc.sysinit

					/etc/rc.d/rc.sysinit: 系统初始化脚本
						(1) 设置主机名
						(2) 设置欢迎信息
						(3) 激活udev和selinux
						(4) 挂载/etc/fstab文件中定义的文件系统
						(5) 检测根文件系统,并以读写方式重新挂载根文件系统
						(6) 设置系统时钟
						(7) 激活swap设备
						(8) 根据/etc/sysctl.conf文件设置内核参数
						(9) 激活lvm及software raid设备
						(10) 加载额外设备的驱动程序
						(11) 清理操作


					l0:0:wait:/etc/rc.d/rc 0
					l1:1:wait:/etc/rc.d/rc 1
					l2:2:wait:/etc/rc.d/rc 2
					l3:3:wait:/etc/rc.d/rc 3
					l4:4:wait:/etc/rc.d/rc 4
					l5:5:wait:/etc/rc.d/rc 5
					l6:6:wait:/etc/rc.d/rc 6

					说明: rc 0 --> 意味着读取/etc/rc.d/rc0.d/
						K*: K##*: ##运行次序,数字越小,越先运行,数字越小的服务,通常为依赖到别的服务
						S*: S##*: ##运行次序,数字越小,越先运行,数字越小的服务,通常为被依赖到的服务

						for srv in /etc/rc.d/rc0.d/K*; do
							$srv stop
						done

						for srv in /etc/rc.d/rc0.d/K*; do
							$srv start
						done

					
					

					chkconfig命令:
						查看服务在所有级别的启动或关闭设定情形:
							chkconfig [--list] [name]

						添加:
							符合SysV风格的服务脚本放置于/etc/rc.d/init.d(/etc/init.d)

							chkconfig --add name

								#!/bin/bash
								#
								# chkconfig: LLLL nn nn

						删除
							chkconfig --del name

						修改指定的链接类型
							chkconfig [--level levels] name <on|off|reset>
								--level LLLL: 指定要设置的级别: 省略时表示2345

					注意: 正常级别下,最后启动的一个服务S99local没有链接到/etc/rc.d/init.d中的脚本,而是指向了/etc/rc.d/rc.local脚本. 
					因此,可以把不便或者不需要写为服务脚本(放置于/etc/rc.d/init.d目录),且有想在开机时自动运行的命令,可以直接写在/etc/rc.d/rc.local文件中.

					# Trap CTRL-ALT-DELETE						//当你按下这个组合键所对应的操作
					ca::ctrlaltdel:/sbin/shutdown -t3 -r now

						
					# Run gettys in standard runlevels			//启动6个物理终端
					1:2345:respawn:/sbin/mingetty tty1
					2:2345:respawn:/sbin/mingetty tty2
					3:2345:respawn:/sbin/mingetty tty3
					4:2345:respawn:/sbin/mingetty tty4
					5:2345:respawn:/sbin/mingetty tty5
					6:2345:respawn:/sbin/mingetty tty6

						mingetty会调用login程序

					# Run xdm in runlevel 5
					x:5:respawn:/etc/X11/prefdm -nodaemon

			总结: /sbin/init --> (/etc/inittab) --> 设置默认运行级别 --> 运行系统初始化脚本,完成系统初始化 --> 
			关闭对应级别下需要关闭的服务, 启动需要启动的服务 --> 设置登录终端

		CentOS 6:
			
			init程序为: upstart(ubuntu研发的), 其配置文件:
				/etc/inittab, /etc/init/*.conf

				注意: /etc/init/*.conf文件语法 遵循 upstart配置文件语法格式.

		博客作业: 系统启动流程

		启动系统是,设置其运行级别为1:

回顾:
	CentOS 6启动流程:
		POST --> Boot Sequence(BIOS) --> Boot loader(MBR) --> Kernel(ramdisk) --> rootfs --> switch root --> /sbin/init -->
		(/etc/inittab, /etc/init/*.conf) --> 设定默认运行级别 --> 系统初始化脚本 --> 关闭或启动对应级别下的服务 --> 启动终端

GRUB(Boot Loader):
	
	grub: Grand Unified Bootloader
		grub 0.x: grub legacy
		grub 1.x: grub2

		查看grub的版本:
			# grub-install -v
			# grub2-install --version

	grub legacy:
		stage1: mbr
		stage1_5: mbr之后的扇区(MBR后到第一个分区前的中间那段空间, MBR gap,这段空间最小31KB，但一般都会是1MB左右.),
				让stage1中的boot loader能识别stage2所造的分区上的文件系统
		stage2: 在磁盘分区上(/boot/grub), 其实内核文件,ramdisk也在这个分区上.

		配置文件:  /boot/grub/grub.conf <-- /etc/grub.conf

		stage2以及内核等文件通常放置于一个基本的磁盘分区(所谓基本:表示正常的分区而不是lvm, 软raid之类的复杂系统)
			功用:
				(1) 提供菜单并提供交互式接口
					e: 编辑模式,用于编辑菜单
					c: 命令模式, 交互式接口
				(2) 加载用户选择的内核或操作系统
					允许传递参数给内核
					可隐藏此菜单
				(3) 为菜单提供了保护机制
					为编辑菜单进行认证(有密码才能编辑)
					为启用内核或操作系统进行认证(输入密码才能启用)
			tips: /boot可以自己单独一个分区,也可以和/使用同一个分区. /boot之所以单独一个分区,是因为stage2本身不能加载复杂系统的驱动(它本身存放的位置空间很小),
			而有的人需要/分区是一个复杂的系统,例如要使用raid或者lvm作为根(/)的分区, 这种情况下需要把/boot单独使用一个简单分区.
			如果你的根文件系统不需要复杂的系统,那么/boot和/放在一个分区也是可以的.

		如何识别设备:
			(hd#,#)
				hd#: 磁盘编号,用数字表示,从0开始编号
				#: 分区编号,用数字表示,从0开始编号

				(hd0,0): 表示第1块磁盘的第1个分区

		
		grub的命令行接口
			help: 获取帮助列表
			help KEYWORD: 详细帮助信息
			find (hd#,#)/PATH/TO/SOMEFILE:
			root (hd#,#)
			kernel /PATH/TO/KERNEL_FILE: 设定本次启动时用到的内核文件, 额外的还可以添加许多内核支持使用的命令行参数
				例如: init=/path/to/init, selinux=0
			initrd /PATH/TO/INITRAMFS_FILE: 设定为选定的内核提供辅助功能的文件ramdisk
			boot: 引导启动选定的内核

			手动在grub命令行接口启动系统:
				grub> root (hd#,#)
				grub> kernel /vmlinuz-VERSION-RELEASE ro root=/dev/DEVICE(不过我测试下来这里应该是写根文件系统的分区)
				grub> initrd /initramfs-VERSION-RELEASE.img
				grub> boot
					例如: 	kernel /vmlinuz-2.6.32-504.el6.x86_64 ro root=/dev/sda2
							kernel /vmlinuz-2.6.32-504.el6.x86_64 ro root=/dev/dm-0
							kernel /vmlinuz-2.6.32-504.el6.x86_64 ro root=/dev/mapper/VolGroup-lv_root

		配置文件: /boot/grub/grub.conf
			配置项:
				default=#: 设定默认启动的菜单项, 菜单项(title)编号从0开始
				timeout=#: 指定菜单项等待选项选择的时长
				splashimage=(hd#,#)/PATH/TO/XPM_PIC_FILE: 指明菜单背景图片文件路径
				hiddenmenu: 隐藏菜单
				password [--md5] STRING: 菜单编辑认证, 密码可以是明文也可以是加密的
				title TITLE: 定义菜单项"标题", 可出现多次
					root (hd#,#): grub查找stage2及kernel文件所在设备分区. 是grub的"根"
					kernel /PATH/TO/VMLINUZ_FILE [PARAMETERS]: 启动的内核以及相关的内核参数
					initrd /PATH/TO/INITRAMFS_FILE: 内核匹配的ramfs文件
					password [--md5] STRING: 启动选定的内核或操作系统是进行认证

			grub-md5-crypt命令: 用来生成一个md5的字符串
			openssl命令也可以做这件事情

			[root@localhost ~]# cat /boot/grub/grub.conf 
			# grub.conf generated by anaconda
			#
			# Note that you do not have to rerun grub after making changes to this file
			# NOTICE:  You have a /boot partition.  This means that
			#          all kernel and initrd paths are relative to /boot/, eg.
			#          root (hd0,0)
			#          kernel /vmlinuz-version ro root=/dev/VolGroup00/LogVol00
			#          initrd /initrd-version.img
			#boot=/dev/sda
			default=0
			timeout=5
			splashimage=(hd0,0)/grub/splash.xpm.gz
			hiddenmenu
			title CentOS (2.6.18-398.el5)
				root (hd0,0)
				kernel /vmlinuz-2.6.18-398.el5 ro root=/dev/VolGroup00/LogVol00 rhgb quiet
				initrd /initrd-2.6.18-398.el5.img

		进入单用户模式(可以重置root用户的密码,因为这个模式登录不要求输入密码,直接进入系统):
			(1) 编辑grub菜单(先选定要编辑的tilte,然后按下e按键)	
			(2) 在选定的kernel后面,再次按下e按键,编辑kernel这一行,在最后面附加参数:
					1, s, S 或者 single 都可以
			(3) 将光标移动到kernel所在的行, 键入b命令

		安装grub: 有两种方式
			(1) grub-install
				# grub-install --root-directory=ROOT(boot目录所在的父目录) /dev/DISK
				强烈注意: 老师讲解的时候说grub-install命令很轴, 它要求在ROOT下面必须已经存在boot目录.
				我自己做测试的时候发现如果你没有提前创建boot目录,grub-install会自动创建boot目录.
				这时我以为老师讲错了.
				殊不知后面有坑, 在做下面的练习1的时候, 按照基本的步骤启动系统会报错error 15 file not found.
				折腾了很久在网上发现,这个grub.conf文件中配置kernel和initrd的时候有的人是在/目录下,而另外一些人是在/boot下,两者之间差一级目录boot.
					kernel /vmlinuz-2.6.18-398.el5 ro root=/dev/VolGroup00/LogVol00 rhgb quiet
					kernel /boot/vmlinuz-2.6.18-398.el5 ro root=/dev/VolGroup00/LogVol00 rhgb quiet
				而我之所以报错就是差了一级目录,按照grub.conf中的路径的确是找不到vmliuz文件,然后就error 15 file not found,
				所以前面老师说grub-install轴,非要提前准备boot目录.
				不是空穴来风(不过我后来又做了测试,按照老师的这样做也是差一级boot目录,但是老师在视频中是没有问题的,反正注意一下路径就对了).
				总结: 在设定了root (hd0,0) 之后如果找不到文件,要查一下是否就是差了这一级boot目录,总的原则就是要让路径匹配的上,能找到kernel文件和ramdisk文件
				2022/02/16 我在尝试LFS之后有了新的发现: 在LFS-BOOK-11.0中的10.4.4.章节 (创建 GRUB 配置文件) 写到:
					cat > /boot/grub/grub.cfg << "EOF"
					# Begin /boot/grub/grub.cfg
					set default=0
					set timeout=5

					insmod ext2
					set root=(hd0,2)

					menuentry "GNU/Linux, Linux 5.13.12-lfs-11.0" {
							linux   /boot/vmlinuz-5.13.12-lfs-11.0 root=/dev/sda2 ro
					}
					EOF

					从 GRUB的视角来看，内核文件的位置相对于它使用的分区。
					如果您使用了单独的 /boot 分区，需要从上面的 linux 行删除 /boot，然后修改 set root 行，指向 /boot 分区。
				所以到底有没有boot这一级目录需要看/boot是否单独做了分区,如果单独分区,就不用boot这一级目录.

			(2) grub
				grub> root (hd#,#)
				grub> setup (hd#)

			Note:第2种方式要求所指定的磁盘上必须已经存在grub目录,而且其所包含的stage1 stage2以及各种各样的stage1_5文件都必须是已经存在的 
				 第1种方式则没有这些限制.

		练习:
			1. 新添加一块硬盘,提供直接单独运行bash系统
				(1)添加一块磁盘/dev/sdc

					#fdisk /dev/sdc 			//给硬盘分区
						   Device Boot      Start         End      Blocks   Id  System
						   /dev/sdc1               1          14      112423+  83  Linux
						   /dev/sdc2              15         276     2104515   82  Linux swap / Solaris
						   /dev/sdc3             277        1321     8393962+  83  Linux
					规划是	/dev/sdc1 是/boot分区,大小100M
							/dev/sdc2 是swap分区,大小是2G,类型是82
							/dev/sdc3 是/分区,大小是8G
					# partx -a /dev/sdc 		//让分区生效
				(2)创建文件系统
					# mkfs -t ext4 /dev/sdc1
					# mkfs -t ext4 /dev/sdc3
					# mkswap /dev/sdc2

				(3)创建挂载点,挂载新添加的硬盘
					[root@localhost ~]# mount /dev/sdc1 /mnt
					[root@localhost mnt]# mkdir /tmp/sysroot
					[root@localhost mnt]# mount /dev/sdc3 /tmp/sysroot/
					

					在将要grub-install的root-directory里面,预先创建好boot目录
					[root@localhost mnt]# cd /mnt
					[root@localhost mnt]# mkdir boot
					[root@localhost mnt]# ls
					boot  lost+found
				(4) 安装grub,创建grub配置文件,准备内核文件,ramdisk文件
					[root@localhost mnt]# grub-install --root-directory=/mnt /dev/sdc
					[root@localhost mnt]# cp /boot/vmlinuz-2.6.32-504.el6.x86_64 /mnt/boot/
					[root@localhost mnt]# cp /boot/initramfs-2.6.32-504.el6.x86_64.img /mnt/boot/
					
					[root@localhost mnt]# vi /mnt/boot/grub/grub.cfg

					default=0
					timeout=5
					title CentOS (made by ft1284595)
					    root (hd0,0)
						kernel /vmlinuz-2.6.32-504.el6.x86_64 ro root=/dev/sda3 selinux=0 init=/bin/bash
						initrd /initramfs-2.6.32-504.el6.x86_64.img

						注意: 这里的kernel和initrd文件的路径是否在/boot目录下,需要好好的斟酌,是在不行就先启动试试,
						在命令行里能确定是到底是直接在/下面,还是在/boot下面
				(5) 准备新磁盘的根文件系统(/dev/sdc3)的相应目录,把本机的/bin/bash命令和其相关的依赖复制过去
					[root@localhost mnt]# cd /tmp/sysroot/
					[root@localhost sysroot]# mkdir -p bin sbin lib lib64 dev etc home root mnt media proc sys srv usr var tmp
					[root@localhost sysroot]# cp /bin/bash /tmp/sysroot/bin/
					[root@localhost sysroot]# ldd /bin/bash
						linux-vdso.so.1 =>  (0x00007fff423ff000)
						libtinfo.so.5 => /lib64/libtinfo.so.5 (0x0000003d24400000)
						libdl.so.2 => /lib64/libdl.so.2 (0x0000003d19800000)
						libc.so.6 => /lib64/libc.so.6 (0x0000003d19c00000)
						/lib64/ld-linux-x86-64.so.2 (0x0000003d19400000)
					[root@localhost sysroot]# cp /lib64/libtinfo.so.5 /tmp/sysroot/lib64/
					[root@localhost sysroot]# cp /lib64/libdl.so.2 /tmp/sysroot/lib64/
					[root@localhost sysroot]# cp /lib64/libc.so.6 /tmp/sysroot/lib64/
					[root@localhost sysroot]# cp /lib64/ld-linux-x86-64.so.2 /tmp/sysroot/lib64/
					[root@localhost sysroot]# 

					复制完/bin/bash和其相关依赖之后可以使用chroot命令 检测一下是否可以运行
					[root@localhost sysroot]# chroot /tmp/sysroot/
					bash-4.1# 									//能切换到bash就说明是成功的
					bash-4.1# exit
					exit
					[root@localhost sysroot]# sync				//同步数据到磁盘
					[root@localhost sysroot]# 



				(6) 新建一个虚拟机使用这个/dev/sdc作为系统盘启动.
					
					
				kernel /vmlinuz ro root=/dev/sda3 selinux=0 init=/bin/bash
				注意: selinux参数在init之前表示不启动selinux策略(因为我们本身什么都没装啊,就拷贝了bash这一个程序),写在后面没有用,会报错kernel panic...
				
			2. 破坏本机grub stage1, 而后在救援模式下修复好系统
			3. 为grub设置保护功能

		博客作业: grub应用

Linux Kernel:
	
	单内核体系设计,但充分借鉴了微内核设计体系的有点, 为内核引入模块化机制
		内核的组成部分:
			kernel: 内核核心, 一般为bzImage压缩格式, 通常在/boot目录下, 名称为vmlinuz-VERSION-RELEASE
			kernel object: 内核对象, 一般放置于/lib/modules/VERSION-RELEASE/
				[ ]: N			//不编译这个模块,表示不支持这个功能
				[M]: M			//编译成模块
				[*]: Y			//编译进内核

			辅助文件: ramdisk
				initrd
				initramfs
	
	运行中的内核:
		
		uname 命令:
			uname - print system information
			uname [OPTION]...
				-n: 显示节点名称
				-r: 显示VERSION-RELEASE
				-a: 显示所有信息

		模块:
			lsmod命令:
				显示由核心已经装在的内核模块

				显示的内容来自于: /proc/modules文件

			modinfo命令:
				显示模块(即使这个模块还没被装载进内核中)的详细描述信息

				modinfo [ -k kernel ] [modulename | filename...]
					-n: 显示模块的路径
					-p: 显示模块参数
					-a: author
					-d: description
					-l: licence

			modprobe命令:
				装载或卸载内核模块

				modprobe [ -C config-file ] [ modulename] [ module parameters...]
					装载指定的模块, 默认的配置文件是: /etc/modprobe.conf, /etc/modprobe.d/*.conf

				mobprobe -r modulename...
					卸载模块

			depmod命令:
				内核模块依赖关系文件及系统信息映射文件的生成工具

			装载或卸载内核模块:
				insmod命令
					insmod [filename] [module options...]
						filename: 是模块文件的真实路径, 可以用modinfo -n 模块名 先查找路径
						
					[root@localhost ~]# insmod $(modinfo -n xfs)
					insmod: error inserting '/lib/modules/2.6.32-504.el6.x86_64/kernel/fs/xfs/xfs.ko': -1 Unknown symbol in module
					//报错是因为这个模块依赖其它模块
					[root@localhost ~]# modinfo xfs
					filename:       /lib/modules/2.6.32-504.el6.x86_64/kernel/fs/xfs/xfs.ko
					license:        GPL
					description:    SGI XFS with ACLs, security attributes, large block/inode numbers, no debug enabled
					author:         Silicon Graphics, Inc.
					srcversion:     4392D4D583B9D2781E4F61E
					depends:        exportfs					//依赖的模块
					vermagic:       2.6.32-504.el6.x86_64 SMP mod_unload modversions 
					[root@localhost ~]# modinfo -n xfs
					/lib/modules/2.6.32-504.el6.x86_64/kernel/fs/xfs/xfs.ko
					由上面的命令可以看出要装载xfs模块,需要先装载exportfs模块
				rmmod命令
					rmmod [modulename]

				insmod,rmmod和上面modprobe装载,卸载模块不同. insmod,rmmod这组命令只会装(卸)载指定的模块,如果模块依赖其它模块,需要你自己手动安装被依赖的模块.

	/proc目录
		内核把自己内部状态信息及统计信息,以及可配置的参数通过proc伪文件系统加以输出

		参数: 
			只读: 输出信息
			可写: 可接受用户指定"新值"来实现对内核某个功能或特性的配置
				可写的参数一般都在/proc/sys目录下
				由于/proc下是伪文件,所以不能通过文本编辑器去修改,想要修改这些值有2种办法:
				(1) sysctl命令: 用于查看或设定此目录(/proc/sys)下的诸多参数
					sysctl -w path.to.parameter=VALUE

					# sysctl -w kernel.hostname=mail.google.com

				(2) echo命令通过重定向的方式也可以修改大多数的值
					echo "VALUE" > /proc/sys/path/to/paramater

					# echo "www.netflix.com" > /proc/sys/kernel/hostname

			sysctl命令: - configure kernel parameters at runtime.
				配置文件: /etc/sysctl.conf
				sysctl命令可以通过读取/etc/sysctl.conf配置文件来修改内核参数. 修改完配置文件之后,需要使用 sysctl -p 来使新的配置生效.
					(1) 设置某参数
						sysctl -w parameter=VALUE
					(2) 通过读取配置文件设置参数
						sysctl -p [/path/to/conf_file]

			内核中的路由转发:
				/proc/sys/net/ipv4/ip_forward

				常用的几个参数:
					net.ipv4.ip_forward
					vm.drop_caches
					kernel.hostname

	/sys目录:
		
		sysfs: 输出内核识别出的各个硬件设备的相关属性信息,也有内核对硬件特性的设定信息.有些参数是可以修改的,用于调整硬件工作特性

		udev通过此路径下输出的信息动态的为各个设备创建所需要的设备文件. udev是运行在用户空间的程序. 专用工具: udevadmin, hotplug

		udev为设备创建设备文件时,会读取其事先定义好的规则文件,一般在/etc/udev/rules.d及/usr/lib/udev/rules.d目录下
	
	ramdisk文件的制作:
		有一种情况,主机的系统上根分区本来是一个基本的磁盘分区, 后来觉得根分区里的很多文件都很重要,所以把根分区转移到一个raid1中.
		在这种情况下,由于原来的根分区是在基本分区上的，所以系统上原始安装生成的ramdisk文件应该是没有包含raid1的驱动的.这时就需要
		重新制作ramdisk文件了.

		有2种制作方法
		(1) mkinitrd 命令: 它其实是调用dracut来完成制作的
			为当前正在使用的内核重新制作ramdisk文件
				# mkinitrd /boot/initramfs-$(uname -r).img $(uname -r)

		(2) dracut命令
			为当前正在使用的内核重新制作ramdisk文件
				# dracut /boot/initramfs-$(uname -r).img $(uname -r)
	
	编译内核:
		前提:
			(1) 准备好开发环境
			(2) 获取目标主机上硬件设备的相关信息
			(3) 获取到目标主机系统功能的相关信息, 例如要启用的文件系统
			(4) 获取内核源代码包
				www.kernel.org


		准备好开发环境:
			包组(CentOS 6)
				Development Tools
				Server Platform Development
					Development Tools
					Server Platform Development

		目标主机硬件设备相关信息:
			CPU:
				# cat /proc/cpuinfo
				# x86info -a
				# lscpu

			PCI设备:
				# lspci
					-v
					-vv

				# lsusb
					-v
					-vv

				# lsblk

			了解全部硬件设备信息:
				# hal-device

		简单依据模板文件的制作过程
			# tar xf linux-3.10.67.tar.xz -C /usr/src
			# cd /usr/src
			# ln -sv linux-3.10.67 linux
			# cd linux
			# cp /boot/config-$(uname -r) ./.config

			# make menuconfig
			# screen
			# make -j 4
				启动4个线程一起编译内核
			# make modules_install
			# make install
				注意: 可以使用screen或tmux来编译,以免终端被关闭而终止了编译进度.
			
			这一步好像会报一个vmware相关模块的错误,貌似不影响编译结果.

			重启系统,并测试使用新内核

			# make help 
				可以查看很多编译选项
		练习: 编译好, 并启用之

回顾: 内核组成部分,内核编译

	内核组成部分:
		核心, 模块
		核心: /boot/vmlinuz-VERSION-RELEASE
		模块: /lib/modules/VERSION-RELEASE/

		模块管理的相关命令:
			lsmod, modinfo, modprobe [r], insmod, rmmod, depmod

		内核编译:
			[ ]
			[*]
			[M]

			步骤:
				make menuconfig: 配置内核选项
					生成配置文件 .config: 这是一个文本文件
				make [-j #]
					启动多线程编译内核
				make modules_install
				make install
					安装bzImage为/boot/vmlinuz-VERSION-RELEASE
					生成initramfs文件
					生成新的grub的配置文件(在原来的基础上添加新编译的内核title)

				注意: 可以使用screen或tmux来编译,以免终端被关闭而终止了编译进度.

Linux内核编译(2)
	
	编译内核的步骤:
		(1) 配置内核选项
			支持"更新"模式进行配置
				(a) make config: 基于命令行以遍历的方式去配置内核中可配置的每个选项
				(b) make menuconfig: 基于curses的文本窗口界面
				(c) make gconfig: 基于GTK开发环境的窗口界面
				(d) make xconfig: 基于QT开发环境的窗口界面
			支持"全新配置"模式进行配置:
				(a) make defconfig: 基于内核为目标平台提供的"默认"配置进行配置
				(b) make allnoconfig: 所有选项均回答为"no"

		(2) 编译
			make [-j #] : 开启多线程模式进行编译

			如何只编译内核中的一部分功能:
				(a) 只编译某个子目录中的相关代码:
					# cd /usr/src/linux
					# make dir/

				(b) 只编译一个特定的模块:
					# cd /usr/src/linux
					# make dir/file.ko

					例如: 只为e1000编译驱动:
						# cd /usr/src/linux
						# make drivers/net/ethernet/intel/e1000/e1000.ko

			如何交叉编译内核:
				编译的目标平台与当前平台不相同:
				
				# make ARCH=arch_name

				要获取特定目标平台的使用帮助
				# make ARCH=arch_name help

	如何在已经执行过编译操作的内核源码树做重新编译:
		事先清理操作:
			# make clean: 清理大多数编译生成的文件,但会保留config文件等.
			# make mrproper: 清理所有编译生辰过的文件, config以及某些备份文件.
			# make distclean: mrproper,patches以及编辑器备份文件.

	
	screen命令:
		打开新的screen:
			# screen
		退出并关闭screen:
			# exit
		剥离当前screen:
			Ctrl+a, d
		显示所有已经打开的screen:
			screen -ls
		恢复某个screen:
			screen -r [SESSION]

CentOS系统安装:
	
	bootloader --> kernel(initramfs) --> rootfs --> /sbin/init

	anaconda: 安装程序
		tui: 基于curses的文本窗口
		gui: 图形窗口
	
	CentOS的安装程序启动过程
		MBR(这是一个安装在光盘上模拟的MBR): boot.cat
		stage2: isolinux/isolinux.bin
			配置文件: isolinux/isolinux.cfg

			每个对应的菜单选项
				加载内核: isolinuz/vmlinuz
				向内核传递参数: append initrd=initrd.img ...

			itrd是特制的,内核加载initrd后就直接启动anaconda安装程序了.它不是像普通的系统启动一样,加载完initrd的这个临时根之后再去切换根.
				它不会去做根目录的切换,而且光盘上也根本就没有什么根分区, 它的目的就是加载initrd这个临时的根来启动anaconda程序.

			装载根文件系统,并启动anaconda

			默认启动GUI接口
			若是显示指定使用TUI接口:
				向内核传递"text"参数即可:
					boot: linux text
		Note: 以上这些内容一般位于引导设备上, 而后续的anaconda以及其安装用到的程序包等文件有几种方式可以提供:
			本地光盘
			本地磁盘
			ftp server: yum repository
			http server: yum repository
			nfs server: 

			如果想手动指定安装源:
				boot: linux method

	anaconda应用的工作过程:
		安装前配置阶段
			安装过程使用的语言
			键盘类型
			安装目标存储设备
				Basic Storage: 本地磁盘, RAID
				特种设备: iSCSI
			设定主机名,配置网络
			时区
			管理员密码
			设定分区方式及MBR的安装位置
			创建一个普通用户
			选定要安装的程序包
		安装阶段
			在目标磁盘创建分区,执行格式化操作等等
			将选定的程序包安装至目标位置
			安装bootloader
		首次启动
			iptables
			selinux
			core dump(核心转储)
			
	anaconda的配置方式:
		(1) 交互式配置方式
		(2) 通过读取事先给定的配置文件自动完成配置
			按照特定的语法给出的配置选项:
				kickstart文件
	
	安装引导选项:(在安装界面按esc按键,进入boot命令行.如果已经进入安装菜单,使用tab键也可以修改相关参数)
		boot:
			text: 文本安装方式
			method: 手动指定使用的安装方法
			与网络相关的引导选项:
				ip=IPADDR
				netmask=MASK
				gateway=GW
				dns=DNS_SERVER_IP
				ifname=NAME:MAC_ADDR
			与远程访问功能相关的引导选项:
				vnc
				vncpassword='PASSWORD'
			指明kickstart文件的位置(可以在很多地方)
				ks=
					DVD drive: ks=cdrom:/PATH/TO/KICKSTART_FILE
					Hard drive: ks=hd:/device/directory/KICKSTART_FILE
					HTTP server: ks=http://host:port/path/to/KICKSTART_FILE
					FTP server: ks=ftp://host:port/path/to/KICKSTART_FILE
					HTTPS server: ks=https://host:port/path/to/KICKSTART_FILE
			启动紧急救援模式:
				rescue

			官方文档: <<Installation Guide>>
	
	kickstart文件格式:
		命令段: 指明各种安装前配置, 如键盘类型,时区等等
		程序包段: 指明要安装的程序包组或程序包,不安装的程序包等等
			%packages         	程序包段的开始标记
			@group_name			包组
			package				要装的包
			-package			不要装的包
			%end				程序包段的结束标记
		脚本段:
			%pre: 安装启动之前需要运行的脚本
				运行环境: 运行于安装介质上的微型linux环境

			%post: 安装完成之后需要运行的脚本
				运行环境: 就是安装完成的系统

		命令段中的命令:
			必备命令
				authconfig: 认证方式
					authconfig --enableshadow --passalgo=sha512
				bootloader: bootloader的安装位置及相关配置
					bootloader --location=mbr --driveorder=sda --append="crashkernel=auto rhgb quiet"
				keyboard: 设定键盘类型
				lang: 语言类型
				part: 创建命令
				rootpw: 指明管理员的密码
				timezone: 指明时区

			可选命令
				install OR upgrade
				text: 文本安装界面
				network
				firewall
				selinux
				halt
				poweroff
				reboot
				repo
				user: 安装完成以后创建新用户
				url: 指明安装源

		创建kickstart文件的方式:
			(1) 直接手动编辑
				依据某个模板修改
			(2) 可使用创建工具: system-config-kickstart(CentOS6)
				依据某个模板修改并生成新的配置

		检查ks文件中的语法错误: ksvalidator
			# ksvalidator /PATH/TO/KICKSTART_FILE

		创建引导光盘:

			# mkisofs -R -J -T -v --no-emul-boot --boot-load-size 4 --boot-info-table -V "CentOS6.6 x86_64 boot" 
			-b isolinux/isolinux.bin -c isolinux/boot.cat -o /root/boot.iso myiso/

			myiso目录中的内容如下:(isolinux中的文件是从系统的安装光盘中复制过来的,myks.cfg是自己配置的kickstart文件)
				[root@localhost tmp]# tree /tmp/myiso/
				/tmp/myiso/
				├── isolinux
				│   ├── boot.cat
				│   ├── boot.msg
				│   ├── grub.conf
				│   ├── initrd.img
				│   ├── isolinux.bin
				│   ├── isolinux.cfg
				│   ├── memtest
				│   ├── splash.jpg
				│   ├── TRANS.TBL
				│   ├── vesamenu.c32
				│   └── vmlinuz
				└── myks.cfg


		创建好的光盘可以在启动的时候手动添加ks文件存放为值的参数,这样光盘就可以直接安装系统.也可以将ks参数做在一个ks文件中的一个label中.
			例如: 
				label linux
				  menu label ^Install or upgrade an existing system
				  menu default
				  kernel vmlinuz
				  append initrd=initrd.img ks=cdrom:/myks.cfg

回顾: CentOS 系统安装
	kickstart文件:
		命令段
			必备: authconfig, bootloader, ...
			可选: firewall, selinux, reboot, ...
		程序包段:
			%packages
			@group_name
			package
			-package
			%end
		脚本段
			%pre
			...
			%end

			%post
			...
			%end

	创建kickstart文件的工具: system-config-kickstart	
	语法检查: ksvalidator

	安装过程如何获取kickstart文件:
		DVD: cdrom:/PATH/TO/KS_FILE
		HTTP: http://HOST:PORT/PATH/TO/KS_FILE


SELinux:

	SELinux: Secure Enhanced Linux, 工作于Linux内核中.

	DAC: 自主访问控制
	MAC: 强制访问控制

	SELinux有两种工作级别:
		strict: 每个进程都收到selinux的控制
		targeted: 仅有限个进程收到selinux控制
			只监控容易被入侵的进程. 
		
	sandbox:

		subject operation object

			subject: 进程
			object: 进程,文件
				文件: open, read, write, close, chown, chmod

			subject: domain
			object: type

		SELinux为每个文件提供了安全标签,也为进程提供了安全标签.这个标签由:分隔的5段信息.
				对于targeted级别的centos来说,最后的2个字段没有作用.
			user:role:type(domain):敏感度:		//对于文件就是type,对于进程则是domain
				user: SELinux的user
				role: 角色
				type: 类型

			-Z 参数可以查看这个安全标签.
			# ls /etc -Z
			# ps auxZ

		SELinux规则库:
			规则: 哪种域能访问哪种或哪些类型的文件	
	
	配置SELinux:
		SELinux是否启用
		给文件重新打标签
		设定某些布尔型特性


		SELinux的状态:
			enforcing:强制, 每个受限的进程都必然受限
			permissive: 启用, 每个受限的进程违规操作不会被禁止,但是会被记录与审计日志
			disable: 关闭
			注意: 当SELinux从disable切换到别的状态时,需要重新启动系统,因为需要对文件重新打标签.

			相关命令:
				getenforce: 获取selinux当前状态
				setenforce 0|1
					0: 设置为permissive
					1: 设置为enforcing
				此设定: 重启系统后就会失效.
				
				配置文件: /etc/sysconfig/selinux, /etc/selinux/config
					SELINUX={disabled|enforcing|permissive}
		
		给文件重新打标签:
			chcon - change file SELinux security context.
				chcon [OPTION]... CONTEXT FILE...
				chcon [OPTION]... [-u USER] [-r ROLE] [-t TYPE] FILE...
				chcon [OPTION]... --reference=RFILE FILE...
					-R: 递归打标签

				# chcon -t user_tmp_t home.txt 		//将home.txt的标签修改为 user_tmp_t
		
		还原文件的默认标签:
			restorecon - restore file default SELinux security context.
			restorecon [-R] /path/to/somewhere
		
		布尔型规则:
			getsebool
			setsebool

			getsebool命令:
				getsebool [-a] [boolean]
			setsebool命令:
				setsebool [-P] boolean value | bool1=val1 bool2=val2
					-P: 表示将这条规则保存到规则库中,永久有效. 如果没有这个选项,下次重启系统后就失效了.
		审计日志文件:
			/var/log/audit/audit.log
		
		<<SELinux权威指南>>,一本古老的书

bash脚本编程:
	编程语言:
		数据结构

		顺序执行
		选择执行
			条件测试
				运行命令或[[]]
					执行状态返回值:
			if
			case
		循环执行
			将某代码段重复运行多次:
			重复运行多次?
				循环次数事先已确定
				循环次数事先不能确定

				必须有进入条件和退出条件:

			for, while, until	
		
		函数: 结构化编程及代码重用:
			function
	
	for 循环语法:
		for NAME in LIST; do
			循环体
		done

		LIST列表生成方式:
			(1) 整数列表
				{start..end}
				$(seq start [[step]end])
			(2) glob
				/etc/rc.d/rc3.d/K*
			(3) 命令
	通过ping命令探测192.168.4.1~254范围内的所有主机的在线状态:
		#!/bin/bash
		#
		net='192.168.4'
		uphosts=0
		downhosts=0

		for i in {1..255}; do
			ping -c 1 -w 1 ${net}.${i} &> /dev/null
				if [ $? -eq 0 ]; then
					echo "${net}.${i} is up."
					let uphosts++
				else
					echo "${net}.${i} is down."
					let downhosts++
				fi
		done

		echo "Up hosts: $uphosts."
		echo "Down hosts: $downhosts."

while循环:
	while CONDITION; do
		循环体
	done

	CONDITION: 循环控制条件, 进入循环之前,先做一次判断,每一次循环之后会再次做判断。
		条件为"true", 则执行一次循环,知道条件测试状态为"false"终止循环.

		因此: CONDITION一般应该有循环控制变量, 而此变量的值会在循环体中不断的被修正

	示例: 求100以内所有正整数只和:
		#!/bin/bash

		declare -i sum=0
		declare -i i=1

		while [ $i -le 100 ]; do
			let sum+=$i
			let i++
		done

		echo "sum=${sum}."
	
	练习: 添加10个用户user1-user10
		#!/bin/bash
		#
		declare -i i=1
		declare -i users=0

		while [ $i -le 10 ]; do
			if ! id user$i &>/dev/null; then
				useradd user$i
				echo "Add user: user$i"
				let users++
			fi
			let i++
		done

		echo "Add $users users."


	练习: 通过ping命令探测192.168.4.1-254范围内的所有主机的在线状态(用while循环)
		#!/bin/bash
		#
		declare -i i=1
		declare -i uphosts=0
		declare -i downhosts=0

		net='192.168.4'

		while [ $i -le 254 ]; do
			if ping -c 1 -w 1 $net.$i &> /dev/null; then
				echo "$net.$i is up."
				let uphosts++
			else
				echo "$net.$i is down."
				let downhosts++
			fi
			let i++
		done

		echo "Up hosts: $uphosts."
		echo "Down hosts: $downhosts."


	练习: 打印九九乘法表(分别使用for和while循环实现)
		#!/bin/bash
		#

		for j in {1..9}; do
			for i in $(seq 1 $j); do
				echo -e -n "${i}x${j}=$[i*j] \t"
			done
			echo
		done

		echo "========================================="

		declare -i i=1
		declare -i j=1
		while [ $j -le 9 ]; do
			while [ $i -le $j ]; do
				echo -e -n "${i}x${j}=$[$i*$j]\t"
				let i++
			done
			echo 
			let i=1
			let j++
		done

	练习: 利用RANDOM生成10个随机数字,输出这10个数字,并显示其中的最大者和最小者.
		#!/bin/bash
		#
		declare -i max=0
		declare -i min=0
		declare -i i=1

		while [ $i -le 9 ];do
			rand=$RANDOM
			echo "$rand"
			if [ $i -eq 1 ]; then
				max=$rand
				min=$rand
			fi
			if [ $rand -gt $max ]; then 
				max=$rand	
			fi
			if [ $rand -lt $min ]; then
				min=$rand	
			fi
			let i++
		done

		echo "max: $max"
		echo "min: $min"

回顾: selinux, while
	selinux: 内核,安全加强
		开启:
			/etc/sysconfig/selinux, /etc/selinux/config
			# setenforce
			# getenforce

		打标签:
			chcon [-t TYPE]
				-R
		
		布尔型:
			getsebool [-a]
			setsebool [-P]

	while循环:
		while CONDITION; do
			循环体
		done

sed: 流编辑器

	sed: Stream EDitor, 行编辑器
	sed编辑器中有一个patern space, sed会按照指定的地址定界去按行读取文件中的内容,每读取一行会就将这一行的内容放入patern space,
	在patern space中的内容可以做编辑操作,编辑完后的结果会输出到屏幕上,而不是直接修改文件内容. 除了patern space,sed还有一个hold space

	用法:
		sed [option]... 'script' inputfile...
			'script':
				'地址命令'

			常用选项:
				-n, --quiet, --silent: 不输出模式中的内容至屏幕
				-e: 多点编辑, 可以在一个sed命令中实现多个编辑操作
				-f /PATH/TO/SCRIPT_FILE: 从指定文件中读取编辑脚本
				-r: 支持使用扩展的正则表达式
				-i: 原处编辑,即修改源文件
			
			地址定界:
				(1) 不给地址: 对全文进行处理
				(2) 单地址:
					#: 指定的行
					/pattern/: 被此处模式所能够匹配到的每一行
				(3) 地址范围:
					#1,#2: 从第#1行到#2行
					#,+#1: 从第#行开始到之后的#1行
					/pat1/,/pat2/: 从匹配到pat1的行开始到匹配到pat2的行结束
					#,/pat1/, 从第#行开始, 到匹配到pat1的行结束
				(4) ~: 步进
					1~2: 从第1行开始,步进2行, 相当于显示所有奇数行
					2~2: 从第2行开始,步进2行, 相当于显示所有偶数行
			
			编辑命令:
				d: 删除
				p: 显示模式空间中的内容
				a \text: 在行后面追加文本, 支持使用\n实现多行追加
				i \text: 在行前面插入文本, 支持使用\n实现多行插入
				c \text: 将匹配到的行替换成单行或多行文本
				w /path/to/somefile: 保存模式空间中匹配到的行到一个文件中
				r /path/from/somefile: 读取指定文件的文本流至模式空间中匹配到的行的后面
				=: 为模式空间中的行打印行号
				!: 取反条件,这个命令一般跟在地址定界的后面,可以理解为地址定界的补集.
					# sed '3!d' /etc/fstab		//除了第3行其他的都删除
				s///: 查找替换,支持使用其他分隔符, s@@@, s###
					替换标记:
						g: 行内全局替换
						p: 显示替换成功的行
						w /path/to/somefile: 将替换成功的结果保存至指定的文件中.
					后向引用: 
						(1)使用&
							# sed 's@r..t@&er@' /etc/passwd
						//先匹配rxxt,然后用&引用匹配到的rxxt,把rxxt变成rxxter	
						(2)使用正则表达式的写法
							//修改默认启动级别为图形界面, 把id:x:initdefault: 修改成 id:5:initdefault: 
							# sed "s/\(id:\)[0-6]\(:initdefault:\)/\15\2/" inittab

					练习1: 删除/boot/grub/grub.conf(CentOS 6)文件中所有以空白开头的行的行首的空白字符
						[root@localhost ~]# sed 's@^[[:space:]]\+@@' /boot/grub/grub.conf
						CentOS 7下
						# sed 's@^[[:space:]]\+@@' /etc/grub2.cfg
					练习2: 删除/etc/fstab文件中所有以#开头,后面至少跟一个空白字符的行的行首的#和空白字符
						[root@localhost ~]# sed 's@^#[[:space:]]\+@@' /etc/fstab
					练习3： echo 一个绝对路径个sed命令, 取出其目录名称
						# echo "/etc/sysconfig/" | sed 's@[^/]\+/\?$@@'

					高级编辑命令:(不是很常用)
						h: 把模式空间中的内容覆盖至保持空间(hold space)中
						H: 把模式空间中的内容追加至保持空间中
						g: 从保持空间取出数据覆盖至模式空间
						G: 从保持空间取出内容追加至模式空间
						x: 把模式空间中的内容与保持空间中的内容进行互换
						n: 读取匹配到的行的下一行至模式空间
						N: 追加匹配到的行的下一行至模式空间
						d: 删除模式空间中的行
						D: 删除多行模式空间中的所有行

						sed -n 'n;p' FILE		//显示文件的偶数行
							;是分隔两个命令的分隔符

						sed '1!G;h;$!d' FILE	//逆序显示文件内容, 相当于tac
							$: 表示文件的最后一行,和vim中是一个意思
						sed '$!N;$!D' FILE		//显示文件的最后2行
						sed '$!d' FILE 			//显示文件的最后1行
						sed 'G' FILE			//在文件中的每一行后面增加一个空白行
						sed '/^$/d;G' FILE		//是每行后面都有一个空白行,如果有多个空白行,只保留一个空白行
						sed 'n;d' FILE			//显示文件的奇数行
						sed -n '1!G;h;$p' FILE	//逆序显示文件内容

				注意:
					单独编辑命令p有时会产生你不想要的效果,比如下面这条命令,本意是想将/etc/fstab文件中的UUID开头的行打印出来.
					结果你会发现UUID开头的同一行内容打印了2遍,其他的内容也打印出来了. 这种现象的原因是sed默认会把pattern space的内容都输出到屏幕上,
					当匹配到UUID开头的行的时候,默认的行为打印了一次,然后p命令又打印了一次匹配到的行,所以就打印了2次.
					[root@localhost ~]# sed '/^UUID/'p /etc/fstab

					#
					# /etc/fstab
					# Created by anaconda on Mon Jan  3 11:42:11 2022
					#
					# Accessible filesystems, by reference, are maintained under '/dev/disk'
					# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info
					#
					/dev/mapper/centos-root /                       xfs     defaults        0 0
					UUID=70818158-5cf5-41a3-9050-a8b307917b47 /boot                   xfs     defaults        0 0
					UUID=70818158-5cf5-41a3-9050-a8b307917b47 /boot                   xfs     defaults        0 0
					/dev/mapper/centos-home /home                   xfs     defaults        0 0
					/dev/mapper/centos-swap swap                    swap    defaults        0 0

					想要避免上面的效果可以和-n选项组合使用
					[root@localhost ~]# sed -n '/^UUID/'p /etc/fstab
					UUID=70818158-5cf5-41a3-9050-a8b307917b47 /boot                   xfs     defaults        0 0
			
bash脚本编程

	while CONDITION; do
		循环体
	done			

	进入条件: CONDITION为true
	退出条件: false

	until CONDITION; do
		循环体
	done

	进入条件: false
	退出条件: true

		示例: 求100以内所有正整数之和
			#!/bin/bash
			#

			declare -i i=1
			declare -i sum=0

			until [ $i -gt 100 ]; do
				let sum+=$i
				let i++
			done

			echo "sum=$sum"

		示例: 打印九九乘法表
			#!/bin/bash
			#

			declare -i i=1
			declare -i j=1

			until [ $i -gt 9 ]; do
				until [ $j -gt $i ]; do
					echo -e -n "$j x $i = $[j*i] \t"
					let j++
				done
				let i++
				let j=1
				echo
			done
	
	循环控制语句(用于循环体中):
		continue [N]: 提前结束第N层的本轮循环,而直接进入下一轮判断
			while CONDITION1; do
				COMMAND1
				...
				if CONDITION2; then
					continue
				fi
				CMDn
				...
			done
		
		break [N]: 提前结束循环
			while CONDITION1; do
				COMMAND1
				...
				if CONDITION2; then
					continue
				fi
				CMDn
				...
			done
		
		示例1: 求100以内所有偶数之和,要求循环100以内的所有正整数
			#!/bin/bash
			#
			declare -i i=0
			declare -i sum=0

			until [ $i -gt 100 ]; do
				let i++
				if [ $[$i%2] -eq 1 ];then 
					continue
				fi
				let sum+=$i
			done

			echo "Even sum: $sum"

	创建死循环:
		while true; do
			循环体
		done

		until false; do
			循环体
		done


		示例2: 每隔3秒钟到系统上获取已经登录的用户的信息,如果docker登录了, 则记录与日志中,并退出. 
			#!/bin/bash
			#

			read -p "Enter a user name: " username
			while true; do
				if who | grep "^$username" &> /dev/null; then
					break
				fi
				sleep 3
			done

			echo "$username logged on." >> /tmp/user.log

			第2种实现:
			#!/bin/bash
			#

			read -p "Enter a user name: " username
			until who | grep "^$username" &> /dev/null; do
				sleep 3
			done

			echo "$username logged on." >> /tmp/user.log

	while循环的特殊用法(遍历文件的每一行):
		while read line; do
			循环体
		done < /PATH/FROM/SOMEFILE

		依次读取/PATH/FROM/SOMEFILE文件中的每一行,且将读到的行赋值给变量line

		示例: 找出其ID号为偶数的所有用户, 显示其用户名及ID号
			#!/bin/bash

			while read line; do
				if [ $[`echo $line | cut -d: -f3` %2] -eq 0 ]; then
					echo -e -n "username: `echo $line | cut -d: -f1`\t"
					echo "uid: `echo $line | cut -d: -f3`"
				fi
			done < /etc/passwd
	
	for循环的特殊格式:
		for((控制变量初始化; 条件判断表达式; 控制变量的修正表达式)); do
		done

		示例: 求100以内所有正整数之和
			#!/bin/bash

			declare -i sum=0

			for((i=1; i<=100; i++)); do
				let sum+=$i
			done

			echo "Sum: $sum."
		
		示例2: 打印九九乘法表
			#!/bin/bash
			for((j=1; j<=9; j++));do
				for((i=1; i<=j; i++)); do
					echo -e -n "${i}x${j}=$[$i*$j]\t"
				done
				echo
			done
	
	练习: 写一个脚本,完成如下任务
		(1) 显示一个如下菜单
			cpu) show cpu information;
			mem) show memory information;
			disk) show disk information;
			quit) quit
		(2) 提示用户选择选项
		(3) 显示用户选择的内容

			#!/bin/bash

			cat << EOF
			cpu) show cup information;
			mem) show memory information;
			disk) show disk information;
			quit) quit
			=============================
			EOF

			read -p "Enter a option: " option
			while [ "$option" != 'cpu' -a "$option" != 'mem' -a "$option" != 'disk' -a "$option" != 'quit' ]; do
				read -p "Wrong option, Enter again: " option
			done

			if [ "$option" == 'cpu' ]; then
				lscpu
			elif [ "$option" == 'mem' ]; then
				cat /proc/meminfo
			elif [ "$option" == 'disk' ]; then
				fdisk -l
			elif [ "$option" == 'quit' ]; then
				exit 0
			fi

		进一步地:
			用户选择,并显示完成后不退出脚本,而是提示用户继续选择显示其他内容,知道使用quit才退出.

	条件判断: case语句
		case 变量引用 in 
			PAT1)
				分支1
				;;
			PAT2)
				分支2
				;;
			...
			*)
				默认分支
				;;
		esac
		
		示例:
			#!/bin/bash

			cat << EOF
			cpu) show cup information;
			mem) show memory information;
			disk) show disk information;
			quit) quit
			=============================
			EOF

			read -p "Enter a option: " option
			while [ "$option" != 'cpu' -a "$option" != 'mem' -a "$option" != 'disk' -a "$option" != 'quit' ]; do
				read -p "Wrong option, Enter again: " option
			done

			case "$option" in
				cpu)
					lscpu
					;;
				mem)
					cat /proc/meminfo
					;;
				disk)
					fdisk -l
					;;
				*)
					echo "Quit..."
					exit 0
					;;
			esac

		练习: 写一个脚本,完成如下要求
			(1) 脚本可接受参数: start, stop, restart, status
			(2) 如果参数不是以上的参数,提示用户使用格式后报错退出
			(3) 如果是start,则创建/var/lock/subsys/SCRIPT_NAME, 并显示"启动成功"
				考虑: 如果事先已经启动过一次,该如何处理?
			(4) 如果是stop: 则删除/var/lock/subsys/SCRIPT_NAME, 并显示"停止完成"
				考虑: 如果本来没有start,如何处理?
			(5) 如果是restart, 则先stop,在start
				考虑: 如果本来没有start, 如何处理?
			(6) 如果是status, 则
				如果/var/lock/subsys/SCRIPT_NAME文件存在,则显示"SCRIPT_NAME is running..."
				如果/var/lock/subsys/SCRIPT_NAME文件不存在,则显示"SCRIPT_NAME is stoped..."
			
			其中: SCRIPT_NAME为当前脚本名
	
	总结: until, while, for, case

回顾: sed命令, bash脚本编程

	sed命令:
		sed [options] 'SCRIPT' FILE...

			 编辑命令: d, p, w, r, a, i, c, s, =,
			 	n, N, h, H, g, G, p, P, x, D
	
	bash脚本编程:
		while, for, case, until

bash脚本编程:

	case 变量引用 in 
		pat1)
			分支1
			;;
		pat2)
			分支2
			;;
		...
		*)
			分支n
			;;
	esac

	case 支持glob风格的通配符:
		*: 任意长度的任意字符
		?: 任意单个字符
		[]: 指定范围内的单个字符
		a|b: a或者b

	function: 函数
		过程式编程: 代码重用
			模块化编程
			结构化编程

		语法1:
			function f_name {
				...函数体...
			}

		语法2:
			f_name(){
				...函数体...
			}	

		调用: 函数只有被调用才会执行.
			调用: 给定函数名
				函数名出现的地方, 会被自动替换为函数代码

			函数的生命周期: 被调用时创建, 返回时终止
				return命令返回自定义状态结果
					0: 成功
					1-255: 失败

			#!/bin/bash

			function adduser {
				if id $username &> /dev/null; then
					echo "$usrename exists." 
					return 1
				else
					useradd $username
					[ $? -eq 0 ] && echo "add $username finished." && return 0
				fi
			}

			for i in {1..10}; do
				username=myuser$i
				adduser
			done

			示例: 上一个脚本练习,使用函数封装
				#!/bin/bash
				#
				# chkconfig: - 88 12
				# description: test script for practise function
				#

				prog=$(basename $0)
				lockfile=/var/lock/subsys/$prog

				start(){
					if [ -e $lockfile ]; then
						echo "$prog is already running."
						return 0
					else
						touch $lockfile
						[ $? -eq 0 ] && echo "Starting $prog finished."
					fi
				}

				stop(){
					if [ -e $lockfile ]; then
						rm -f $lockfile && echo "Stop $prog ok."
					else
						echo "$prog is not running yet."
					fi
				}

				status(){
					if [ -e $lockfile ]; then
						echo "$prog is running."
					else
						echo "$prog is stopped."
					fi
				}

				usage(){
					echo "Usage: $prog {start|stop|restart|status}"
				}
				if [ $# -lt 1 ]; then
					usage
					exit 1
				fi

				case $1 in
					start)
						start
						;;
					stop)
						stop
						;;
					restart)
						stop
						start
						;;
					status)
						status
						;;
					*)
						usage
						exit $?
						;;
				esac
			练习: 打印九九乘法表,利用函数实现

		函数的返回值:
			函数的执行结果返回值:
				(1) 使用echo或print命令进行输出
				(2) 函数体中调用命令的执行结果
			函数的退出状态码:
				(1) 默认取决于函数体中执行的最后一条命令的退出状态码
				(2) 自定义退出状态码
					return
		
		函数可以接受参数:
			传递参数给函数: 调用函数时, 在函数名后面以空白分隔给定参数列表即可.

			在函数体中,可以使用$1, $2, ...调用这些参数, 还可以使用$@, $*, $#等特殊变量

			示例: 添加10个用户
				#!/bin/bash

				function adduser {
					if [ $# -lt 1 ]; then
						return 2
						# 2: no arguments
					fi
					if id $1 &> /dev/null; then
						echo "$1 exists." 
						return 1
					else
						useradd $1
						[ $? -eq 0 ] && echo "add $1 finished." && return 0
					fi
				}

				for i in {1..10}; do
					adduser myuser$i
				done
			
			练习: 打印NN乘法表,使用函数实现
		
		变量作用域:
			本地变量: 当前shell进程, 为了执行脚本会启动专用的shell进程, 因此, 本地变量的作用范围是当前shell脚本程序文件.
			局部变量: 函数的生命周期. 函数结束时变量被自动销毁
				如果函数中有局部变量, 其名称同本地变量. 就近原则
			
			在函数中定义局部变量的方法:
				local NAME=VALUE

		函数递归:
			函数直接或间接调用自身

			N!=N(N-1)(N-2)...1
				 #!/bin/bash

				factorial() {
					if [ $1 -eq 0 -o $1 -eq 1 ]; then
						echo 1
					else
						echo $[$1*$(factorial $[$1-1])]
					fi
				}

				factorial 5
			
			练习: 求n阶斐波那契数列
				#!/bin/bash
				#
				fab(){
					if [ $1 -eq 1 ]; then
						echo 1
					elif [ $1 -eq 2 ]; then
						echo 1
					else
						echo $[$(fab $[$1-1])+$(fab $[$1-2])]
					fi
				}

				fab 7

Systemd:
	POST --> Boot Sequence --> Bootloader --> kernel+initramfs(initrd) --> rootfs --> /sbin/init
		init:
			CentOS 5 SysV init
			CentOS 6 Upstart
			CentOS 7 Systemd
	
	Systemd新特性:
		系统引导时实现服务并行启动
		按需激活进程
		系统状态快照
		基于依赖关系定义服务控制逻辑

	核心概念: unit
		配置文件进行标识和配置: 文件中主要包含了系统服务,监听socket,保存的系统快照以及其他与init相关的信息
		保存至:
			/usr/lib/systemd/system
			/run/system/system
			/etc/systemd/system
	
	Unit的类型:
		Service unit: 文件扩展名为.service,用于定义系统服务.
		Target unit: 文件扩展名为.target,用于模拟实现"运行级别"	
		Device unit: .device, 用于定义内核识别的设备
		Mount unit: .mount, 定义文件系统挂载点
		Socket unit: .socket, 用于表示进程间通信用的socket文件
		Snapshot unit: .snapshot, 管理系统快照
		Swap unit: .swap, 用于表示swap设备
		Automount unit: .automount, 文件系统的自动挂载点
		Path unit: .path, 用于定义文件系统中的一个文件或目录

	关键特性:
		基于socket的激活机制: socket与服务程序分离. socket由systemd代为监听,程序不用启动,当systemd探测到有进程访问这个socket的时候,才临时去激活这个服务程序.
								这就可以产生服务的并行启动.
		基于bus的激活机制:
		基于device的激活机制:
		基于path的激活机制:
		系统快照: 保存个unit的当前状态信息于持久存储设备中
		向后兼容sysv init脚本
	
	不兼容:
		systemctl命令固定不变
		非由systemd启动的服务,systemctl无法与之通信
	
	管理系统服务:
		CentOS 7: service unit
			注意: 能兼容早期的服务脚本

			命令: systemctl COMMAND name.service
				.service可以省略

		启动: service name start 	==> systemctl start name.service
		停止: service name stop		==> systemctl stop name.service
		重启: service name restart 	==> systemctl restart name.service
		状态: service name status 	==> systemctl status name.service	
		条件式重启:	service name condrestart	==> systemctl try-restart name.service
		重载或重启服务: systemctl reload-or-restart name.service
		重载或条件式重启服务: systemctl reload-or-try-restart name.service
		禁止设定为开机自启动: systemctl mask name.service
		取消禁止设定为开机自启动: systemctl unmask name.service

		查看某服务当前激活与否的状态: systemctl is-active name.service
		查看所有已经激活的服务:
			systemctl list-units --type service
		查看所有服务:
			systemctl list-units --type service --all
		
		chkconfig命令的对应关系:
			设定某服务开机自启动: chkconfig name on ==> systemctl enable name.service
			禁止开启自启动: chkconfig name off ==> systemctl disable name.service
			查看所有服务的开机自启动状态:
				chkconfig --list ==> systemctl list-unit-files --type service
			查看某服务是否开机自启动: systemctl is-enabled name.service
		
		其他命令:
			查看服务的依赖关系: systemctl list-dependencies name.service
		
	target units:
		unit配置文件: .target

		运行级别:
			0 ==> runlevel0.target, poweroff.target
			1 ==> runlevel1.target, rescue.target
			2 ==> runlevel2.target, multi-user.target
			3 ==> runlevel3.target, multi-user.target
			4 ==> runlevel4.target, multi-user.target
			5 ==> runlevel5.target, graphical.target
			6 ==> runlevel6.target, reboot.target

		级别切换:
			init N ==> systemctl isolate name.target
		
		查看级别:
			runlevel ==> systemctl list-units --type=target

		获取默认运行级别:
			查看/etc/inittab文件 ==> systemctl get-default
		
		修改默认级别:
			修改/etc/inittab文件 ==> systemctl set-default name.target
		
		切换至紧急救援模式:
			systemctl rescue

		切换至emergency模式:
			systemctl emergency
	
	其他常用命令:
		关机: systemctl halt, systemctl poweroff
		重启: systemctl reboot
		挂起: systemctl suspend
		快照: systemctl hibernate
		快照并挂起: systemctl hybrid-sleep

回顾: bash脚本编程, systemd

	函数: 模块化编程
		function f_name {
			函数体
		}

		f_name(){
			函数体
		}

		return 命令:
		参数:
			函数体中调用参数: $1, $2, ...
			$*, $@, $#
		响函数传递参数:
			函数名 函数列表

	systemd: 系统及服务
		unit:
			类型: service, target
				.service, .target
		systemctl 

bash脚本编程:

	变量: 存储单个元素的内存空间
	数组: 存储多个元素的连续的内存空间
		数组名
		索引: 编号从0开始, 属于数值索引
			注意: 索引也可以支持使用自定义的格式, 而不仅仅是数值格式
				bash的数组支持稀疏格式: 即有的位置上有元素,有的位置是空的

		引用数组中的元素: ${ARRAY_NAME[INDEX]}
	
	声明数组: 
		declare -a ARRAY_NAME
		declare -A ARRAY_NAME: 关联数组, (Bash4.0以后才支持这种特性), 就是可以使用key=value的形式访问数组
	
	数组元素的赋值:
		(1) 一次只赋值一个元素:
			ARRAY_NAME[INDEX]=VALUE
				weekdays[0]="Sunday"
				weekdays[4]="Thursday"
		(2) 一次赋值全部元素
			ARRAY_NAME=("VAL1" "VAL2" "VAL3" ...) //空格分隔
		(3) 只赋值特定元素:
			ARRAY_NAME=([0]="VAL1" [3]="VAL2" ...)
		(4) read -a
	
	引用数组元素: ${ARRAY_NAME[INDEX]}
		注意: 省略[INDEX]表示引用下标为0的元素

	数组的长度(数组中元素的个数): ${#ARRAY_NAME[*]}, ${$ARRAY_NAME[@]}

	示例: 生成10个随机数保存于数组中,并找出其中的最大值和最小值
		#!/bin/bash

		declare -a rand
		declare -i max=0

		for i in {0..9}; do
			rand[$i]=$RANDOM
			echo ${rand[$i]}
			[ $[rand[$i]] -gt $max ] && max=${rand[$i]}
		done

		echo "Max: $max"
	
	练习: 写一个脚本
		定义一个数组, 数组中的元素是/var/log目录下所有以.log结尾的文件, 要统计其下标为偶数的文件中的行数只和
			#!/bin/bash

			declare -a files
			files=(/var/log/*.log)
			declare -i lines=0

			for i in $(seq 0 $[${#files[*]}-1]); do
				if [ $[$i%2] -eq 0 ]; then
					let lines+=$(wc -l ${files[$i]} | cut -d' ' -f1)
				fi
			done

			echo "Lines: $lines"
		
	引用数组中的元素:
		所有元素: ${ARRAY[@]}, ${ARRAY[*]}

		数组切片:${ARRAY[@]:offset:number}
			offset: 要跳过的元素个数
			number: 要取出的元素个数, 偏移量之后的所有元素: ${ARRAY[@]:offset}
	
	向数组中追加元素:
		ARRAY[${#ARRAY[*]}]
		
	删除数组中的某个元素:
		unset ARRAY[INDEX]
	
	关联数组:
		declare -A ARRAY_NAME
		ARRAY_NAME=([index_name1]='val1' [index_name2]='val2' ...)

	练习: 生成10个随机数, 升序或降序排序

bash的字符串处理工具:
	字符串切片: 
		${var:offset:number}
		取字符串的最右侧几个字符: ${var: -length}
			注意: 冒号后面必须有一个空白字符
		
	基于模式取子串(这个功能很方便,很重要):
		${var#*word}: 其中word可以是指定的任意字符, 功能:自左而右,查找var变量所存储的字符串中,第一次出现的word,
		删除字符串开头值第一次出现word字符之间的所有字符
		${var##word}: 同上, 不过,删除的是字符串开头至最后一次由word指定的字符之间的所有内容
			[root@localhost bin]# file="/var/log/messages"
			[root@localhost bin]# echo ${file#*/}
			var/log/messages
			[root@localhost bin]# echo ${file##*/}
			messages

		${var%word*}: 其中word可以是指定的任意字符, 功能: 自右而左,查找var变量所存储的字符串中,第一次出现的word,
		删除字符串最后一个字符向左至第一次出现word字符之间的所有字符.
		${var%%word*}: 同上, 只不过删除字符串最右侧的字符向左值最后一次出现word字符之间的所有字符
			[root@localhost bin]# file="/var/log/messages"
			[root@localhost bin]# echo ${file%/*}
			/var/log
			[root@localhost bin]# echo ${file%%/*}

			[root@localhost bin]# 

		示例: url=http://www.magedu.com:80
			${url##*:} --> 80
			${url%%:*} --> http
	
	查找替换:
		${var/pattern/substi}: 查找var所表示的字符串中,第一次被pattern所匹配到的字符串, 以substi替换之
		${var//pattern/substi}: 查找var所表示的字符串中,所有能被pattern所匹配到的字符串, 以substi替换之

		${var/#pattern/substi}: 查找var所表示的字符串中,行首被pattern所匹配到的字符串, 以substi替换之
		${var/%pattern/substi}: 查找var所表示的字符串中,行尾被pattern所匹配到的字符串, 以substi替换之

	查找并删除:
		${var/pattern}: 查找var所表示的字符串中,删除第一次被pattern所匹配到的字符串 
		${var//pattern}: 查找var所表示的字符串中,删除所有被pattern所匹配到的字符串 
		${var/#pattern}: 查找var所表示的字符串中,删除行首被pattern所匹配到的字符串 
		${var/%pattern}: 查找var所表示的字符串中,删除行尾被pattern所匹配到的字符串 
	
	字符大小写转换:
		${var^^}: 把var中的所有小写字母转换为大写
		${var,,}: 把var中的所有大写字母转换为小写
	
	变量赋值:
		${var:-value}: 如果var为空或者未设置,那么返回value, 否则,则返回var的值
		${var:=value}: 如果var为空或者未设置,那么返回value, 并且将value赋值给var, 否则,则返回var的值

		${var:+value}: 如果var不为空,则返回value.
		${var:?error_info}: 如果var为空或未设置, 那么返回error_info(这个error_info是打印在标准错误流上面的), 否则,返回var的值.
	
	为脚本程序使用配置文件:
		(1) 定义文本文件,每行定义"name=value"
		(2) 在脚本中source此文件即可(也可以使用.命令)

			#!/bin/bash

			[ -r /tmp/hostname ] && . /tmp/hostname
			HOSTNAME=${HOSTNAME:-www.magedu.com}

			hostname $HOSTNAME
	
	命令:
		mktemp命令: - create a temporary file or directory
			mktemp [OPTION]... [TEMPLATE]
				TEMPLATE: filename.XXX
					XXX至少出现3次
				OPTION:
					-d: 创建临时目录
					-p, --tmpdir=/PATH/TO/SOMEDIR: 指明临时文件目录位置
			
				[root@localhost tmp]# mktemp test.XXX
				test.5ax
				[root@localhost tmp]# mktemp -d hello.XXX
				hello.Z85
				[root@localhost tmp]# ll
				total 20
				----------. 1 root root  860 Jan 13 17:19 file.txt
				drwx------. 2 root root 4096 Feb 18 02:19 hello.Z85
				drwxr-xr-x. 5 root root 4096 Jan  2 15:37 magedu.com
				drwxr-xr-x. 3 root root 4096 Feb  4 18:26 myiso
				drwx------. 2 root root 4096 Jan 25 20:23 pulse-b9RRFGVCpwOw
				-rw-------. 1 root root    0 Feb 18 02:17 test.5ax
				-rw-------. 1 root root    0 Feb 18 02:18 tmp.cfuptcJzVi



		install命令: - copy files and set attributes.
			install [OPTION]... [-T] SOURCE DEST			//相当于cp
			install [OPTION]... SOURCE... DIRECTORY
			install [OPTION]... -t DIRECTORY SOURCE...
			install [OPTION]... -d DIRECTORY...				//创建一个目录
				选项:
					-m MODE
					-o OWNER
					-g GROUP

			install命令和cp命令的区别在于,install命令可以在创建文件或目录的时候指定权限,属主,属组等attributes.

			[root@localhost tmp]# install -m 700 -d testdir
			[root@localhost tmp]# ll | grep testdir
			drwx------. 2 root root 4096 Feb 18 02:21 testdir

		
	练习: 写一个脚本
		(1) 提示用户输入一个可执行命令名称
		(2) 获取此命令所依赖到的所有库文件列表
		(3) 复制命令至某目标目录(例如/mnt/sysroot)下的对应路径下
			/bin/bash ==> /mnt/sysroot/bin/bash
			/usr/bin/passwd ==> /mnt/sysroot/usr/bin/passwd
		(4) 复制此命令一来到的所有库文件至目标目录下的对应路径下(注意判断原来是否已经有相应的文件,如果有了,不要覆盖,没有文件才复制)
			/lib64/ld-linux-x86-64.so.2 ==> /mnt/sysroot/lib64/ld-linux-x86-64.so.2 
		
		进一步地:
			每次复制完成一个命令后,不要退出,而是提示用户键入新的要复制的命令,并重复完成上述功能, 知道用户输入quit退出.

回顾: bash脚本编程数组:
	数组, 字符串处理

	数组:
		数组: declare -a
			index: 0
		关联数组: decalre -A

	字符串处理:
		切片,查找替换,查找删除,变量赋值
	
GNU awk:

	文本处理三剑客: grep, sed, awk
		grep, egrep, fgrep: 文本过滤工具: pattern
		sed: 行编辑器
			模式空间,保持空间
		awk: 报表生成器,格式化文本输出

		AWK: Aho, Weinberger, Kernighan 最早是在Unix上的工具--> New AWK, NAWK

		GNU awk, gawk 

	gawk - pattern scanning and processing language
		awk: 读取文件中的行, 按照指定的分隔符(默认是空白)来分隔每一行为多个字段, 每个字段存储在相应的位置变量中$1,$2,...($0表示一整行)
		它可以对每一个切割的字段做条件判断, 也可以对单个字段做额外加工和处理. awk可以循环遍历每一行文本,也可以遍历一行文本分隔出来的每一个字段.
		它是一个文本编程语言.
		基本用法: gawk [options] 'program' FILE ...
			program: PATTERN{ACTION STATEMENTS}
				PATTERN: 类似于sed中的文本定界

				语句之间用分号分隔

				print, printf
			
			选项: 
				-F: 指明输入时用到的字段分隔符
				-v var=value: 自定义变量
		
		1. print
			print item1, item2, ...

			要点:
				(1) 逗号分隔符
				(2) 输出的各个item可以是字符串,也可以是数值: 当前巨鹿的字段,变量或者awk的表达式
				(3) 如果省略item,相当于 print $0 (打印整行字符)
		
		2. 变量
			2.1 内置变量
				FS: input field seperator, 默认是空白字符
				OFS: output field seperator, 默认也是空白字符
				RS: input record seperator, 输入时, 行的分隔符符, 默认是换行符
				ORS: output record seperator, 输出时, 行的分隔符, 默认是换行符
					[root@localhost bin]# awk -v FS=':' -v OFS='@' '{print $1,$3,$7}' /etc/passwd

				NF: nuber of field, 每一行的字段总数.
					注意: 引用NF变量,不要加$, 否则就是另外一种意义了
					{print NF},{print $NF} 是两种完全不一样的意思
					[root@localhost bin]# awk '{print NF}' /etc/fstab 	//打印每一行分隔出来的字段数量

					[root@localhost bin]# awk '{print $NF}' /etc/fstab	//相当于打印一行中的某个字段 print $n
				NR: number of record, 当前的行数.
					[root@localhost bin]#  awk '{print NR}' /etc/fstab /etc/issue
				FNR: 各个文件分别计数: 行数.
					[root@localhost bin]# awk '{print FNR}' /etc/fstab /etc/issue

				FILENAME: 当前文件的名称

				ARGC: 命令行参数的个数
				ARGV: 数组,保存的是命令行中给定的各个参数

			2.2 自定义变量
				(1) -v var=value
					变量名区分字符大小写

					[root@localhost bin]# awk -v test='hello gawk' 'BEGIN{print test}'
					hello gawk

				(2) 在program中直接定义变量

					[root@localhost bin]# awk 'BEGIN{test="hello awk";print test}'
					hello awk
			
		3. printf命令
			格式化输出: printf FORMAT, item1, item2, ...

				(1) FORMAT必须要给出
				(2) 不会自动换行, 如果要换行,需要显示给出换行控制符\n
				(3) FORMAT中需要分别为后面的每个item指定一个格式化符号

				格式符:
					%c: 显示字符的ASCII码
					%d, %i: 显示十进制整数
					%e, %E: 科学计数法数值显示
					%f: 显示为浮点数
					%g, %G: 以科学计数法或浮点数形式显示数值
					%s: 显示字符串
					%u: 无符号整数
					%%: 显示%自身

						[root@localhost bin]# awk -F: '{printf "Username:%s\n", $1}' /etc/passwd
						[root@localhost bin]# awk -F: '{printf "Username:%s, UID: %d\n", $1,$3}' /etc/passwd

				修饰符: 修饰格式符
					#[.#]: 第一个数字控制显示的宽度,第二个#表示小数点后的精度
						%3.1f
					-: 左对齐,默认什么都不写是右对齐.
					+: 显示数值的符号
						[root@localhost bin]# awk -F: '{printf "Username:%15s, UID: %d\n", $1,$3}' /etc/passwd
		
		4. 操作符

			算术操作符
				x+y,x-y,x*y,x/y,x^y,x%y
				-x: 负数
				+x: 把一个字符串转换为数值
			
			字符串操作符: 没有符号的操作符, 字符串连接

			赋值操作符:
				=, +=, -=, *=, /=, %/, ^=
				++, --
			
			比较操作符:
				>, >=, <=, !=, ==

			模式匹配符:
				~: 是否匹配
				!~: 是否不匹配
			
			逻辑操作符:
				&&
				||
				!

				[root@localhost bin]# awk -F':' '(NR>=2&&NR<=10){print $1}' /etc/passwd

			函数调用: 
				function_name(arg1, arg2, ...)
			
			条件表达式:
				selector?if-true-expression:if-false-expression
				[root@localhost bin]# awk -F: '{$3>=1000?usertype="Common User":usertype="SysUser"; printf "%15s:%-s\n",$1,usertype}' /etc/passwd
		
		基本用法: gawk [options] 'program' FILE ...
			program: PATTERN{ACTION STATEMENTS}
				
		5. PATTERN
			(1) empty: 空模式,匹配每一行
			(2) /regular expression/: 仅处理能够被正则表达式匹配到的行
					[root@localhost bin]# awk '/^UUID/{print $1}' /etc/fstab 

					!可以表示取反
					[root@localhost bin]# awk '!/^UUID/{print $1}' /etc/fstab
			(3) relational expression: 关系表达式, 结果有"真"有"假". 结果为"真"才会被处理
				真: 结果为非0值,非空字符串
					//显示id大于1000的用户
					[root@localhost bin]# awk -F: '$3>=1000{print $1,$3}' /etc/passwd		
					//显示默认shell是/bin/bash的用户 
					[root@localhost bin]# awk -F: '$NF=="/bin/bash"{print $1,$NF}' /etc/passwd

					[root@localhost bin]# awk -F: '$NF~/bash$/' /etc/passwd
			(4) line ranges: 行范围
				startline,endline: /pat1/,/pat2/
				注意: 不支持直接给出数字的格式,可以使用以下的格式
					//显示文件的第2到10行
					[root@localhost bin]# awk -F':' '(NR>=2&&NR<=10){print $1}' /etc/passwd
			(5) BEGIN/END模式
				BEGIN{}: 仅在开始处理文件中的文本之前执行一次. (例如: 打印表头)
				END{}: 仅在文本处理完成之后执行一次
			注意: 这里的PATTERN有点类似sed中地址定界的意思, 它用来划定需要处理的行的范围,所以这个定界不能在程序体{}
				
				//统计fstab中文件类型出现的次数
				[root@localhost ~]# awk '{/^UUID/fs[$3]++}END{for (i in fs){print i,fs[i]}}' /etc/fstab		//虽然不报错,但不是预期的结果
				[root@localhost ~]# awk '/^UUID/{fs[$3]++}END{for (i in fs){print i,fs[i]}}' /etc/fstab		//正确
		
		6. 常用的action
			(1) Expressions
			(2) Control statements: if, while...
			(3) Compound statements: 组合语句. 
			(4) input statements		
			(5) output statements

		7. 控制语句
			if(condition) {statements}
			if(condition) {statements} else {statements}
			while(condition) {statements}
			do {statements} while(condition)
			for(expr1;expr2;expr3) {statements}
			break
			continue
			next
			delete array[index]
			delete array
			exit
			{statements}

			7.1 if-else
				语法: if(condition) statement [else statement]
				//查看用户(CentOS7)是否是系统用户
				[root@localhost ~]# awk -F':' '{if($3>=1000) {printf "Common user: %s\n",$1} else {printf "root or Sysuser: %s\n", $1}}' /etc/passwd
				//显示默认shell是bash的用户
				[root@localhost ~]# awk -F':' '{if($NF=="/bin/bash") print $1}' /etc/passwd
				//显示以空白分隔字段超过5个的整行文本
				[root@localhost ~]# awk '{if(NF>5) print $0}' /etc/fstab
				//查看文件系统使用比例超过%10的分区
				[root@localhost ~]# df -h | awk -F[%] '/^\/dev/{print $1}' | awk '{if($NF>=10) print $1}'

				使用场景: 对awk取得的整行或摸个字段做条件判断
			
			7.2 while循环
				语法: while(condition) statement
					条件为"真", 进入循环, 条件为"假", 退出循环.

					使用场景: 
						(1)对一行内的多个字段逐一做类似处理时使用. 
						(2)或者对数组中的各个元素逐一处理时使用

					//统计包含linux16的这行文本中, 各个字段的长度					
					[root@localhost ~]# awk '/^[[:space:]]*linux16/{i=1;while(i<=NF){print $i,length($i); i++}}' /etc/grub2.cfg 

					//统计包含linux16的这行文本中, 各个字段的长度, 只显示字段长度大于等于7的字段				
					[root@localhost ~]# awk '/^[[:space:]]*linux16/{i=1;while(i<=NF){if(length($i)>=7) {print $i,length($i)}; i++}}' /etc/grub2.cfg 
			
			7.3 do-while循环
				语法: do statement while(condition)
					意义: 至少执行一次循环体
			
			7.4 for循环
				语法: for(expr1;expr2;expr3) statement

					for(variable assignemnt;condition;iteration process) {for-body}

					[root@localhost ~]# awk '/^[[:space:]]*linux16/{for(i=1;i<=NF;i++) {print $i, length($i)}}' /etc/grub2.cfg
				
				特殊用法:
					能够遍历数组中的元素
						语法: for(var in array) {for-body}
			
			7.5 switch语句
				语法: switch(expression) {case VALUE1 or /REGEXP/: statement; case VALUE2 or /REGEXP2/: statement; ...; default: statement}

			7.6 break和continue
				break[n]
				continue
			
			7.7 next

				awk自身的"continue", 提前结束对本行的处理而直接进入下一行
					//显示id号是偶数的用户
					[root@localhost ~]# awk -F':' '{if($3%2!=0) next; print $1,$3}' /etc/passwd
		
		8. array

			关联数组: array[index-expression]
				index-expression:
					(1) 可以使用任意字符串,字符串要使用双引号""
					(2) 如果某数组元素事先不存在,在引用时,awk会自动创建此元素,并将其值初始化为"空串"
				
					如果要判断数组中是否存在某个元素, 要使用"index in array"格式进行判断.

					weekdays["mon"]="Monday"
					[root@localhost ~]# awk 'BEGIN{weekdays["mon"]="Monday";weekdays["tue"]="Tuesday";print weekdays["mon"]}'
				
				要遍历数组中的每个元素,要使用for循环
					for(var in array) {for-body}
					//遍历数组
					[root@localhost ~]# awk 'BEGIN{weekdays["mon"]="Monday";weekdays["tue"]="Tuesday";for(i in weekdays) {print weekdays[i]}}'
					注意: var会遍历array的每个索引

					state["LISTEN"]++ 
						第一次处理到LISTEN的时候,数组中还没有LISTEN索引,awk数组会将这个数组索引创建出来,索引对应的值是空串(等价于数值0)
						当第2次处理到LISTEN的时候,state["LISTEN"]的值已经被第一次处理的++操作,自增为1了.
					state["ESTABLISHED"]++

					//统计netstat结果中tcp连接的各种状态的总和
					[root@localhost ~]# netstat -tan | awk '/^tcp\>/{state[$NF]++}END{for(i in state){print i,state[i]}}'

					//根据httpd的日志统计各个ip地址访问web服务的次数
					[root@localhost ~]# awk '{ip[$1]++}END{for(i in ip) {print i,ip[i]}}' /var/log/httpd/access_log

					练习1: 统计/etc/fstab文件中每个单词出现的次数
					[root@localhost ~]# awk '{for(i=1;i<=NF;i++){word[$i]++}}END{print "--------------";for(i in word){print i, word[i]}}' /etc/fstab

					练习2: 统计/etc/fstab文件中每个文件系统类型出现的次数
					[root@localhost ~]# awk '/^UUID/{fs[$3]++}END{for (i in fs){print i,fs[i]}}' /etc/fstab		//正确

		9. 函数
			9.1 内置函数
				数值处理:
					rand(): 返回0到1之间的随机数
						rand函数可以生成随机数，但是在使用rand函数时需要配合srand函数,否则rand函数返回的值将一直不变.
					srand(): 配合rand函数使用,生成随机数
					int(): 截取数字整数部分的值
						[root@localhost ~]# awk 'BEGIN{print rand()}'
						0.237788
						[root@localhost ~]# awk 'BEGIN{print rand()}'
						0.237788
						[root@localhost ~]# awk 'BEGIN{srand();print rand()}'
						0.543937
						[root@localhost ~]# awk 'BEGIN{srand();print rand()}'
						0.28783
						[root@localhost ~]# awk 'BEGIN{srand();print int(100*rand())}'
						76
						[root@localhost ~]# awk 'BEGIN{srand();print int(100*rand())}'
						57

					字符串处理函数:
						length([s]): 返回指定字符串的长度
						sub(r,s,[t]): 以r所表示的模式来查找t所表示的字符串中的匹配的内容,并将其第一次出现替换为s所表示的内容
						gsub(r,s,[t]): 以r所表示的模式来查找t所表示的字符串中的匹配的内容,并将其所有出现均替换为s所表示的内容

						split(s,a[,r]): 以r为分隔符切割字符串s,并将切割后的结果保存至a所表示的数组中
						[root@localhost ~]# netstat -tan | awk '/^tcp\>/{split($5,ip,":");count[ip[1]]++}END{for (i in count){print i, count[i]}}'
			9.2 自定义函数

			<<sed 和 awk>>
			<<Linux命令行与Shell脚本编程指南>>